<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-17T11:37:37.090Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>停止心理内耗才能变更强</title>
    <link href="http://example.com/2021/12/12/other/stop-neihao/"/>
    <id>http://example.com/2021/12/12/other/stop-neihao/</id>
    <published>2021-12-12T10:01:54.000Z</published>
    <updated>2023-11-17T11:37:37.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>真正厉害的人，都是“反内耗”体质，只有停止<a class="link"   href="https://www.zhihu.com/search?q=%E5%BF%83%E7%90%86%E5%86%85%E8%80%97" >心理内耗 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，这样才会一步步变强。</p><h2 id="心理内耗特征"><a href="#心理内耗特征" class="headerlink" title="心理内耗特征"></a>心理内耗特征</h2><p>心理内耗往往有如下特征：</p><ol><li>经常觉得累、压力大，其实什么也没干；</li><li>不知道自己想要什么，不知道自己最喜欢和希望的方向是什么；</li><li>即使清楚了自己想要什么，有了方向，什么都还没开始就觉得自己很累了；</li></ol><p>如果以上三条你都符合，那么很可能你的心理内耗比较严重，也就是说你的精神上比较疲惫劳累。</p><h2 id="内耗现象和解决"><a href="#内耗现象和解决" class="headerlink" title="内耗现象和解决"></a>内耗现象和解决</h2><p>当一个人在心理上的损耗和劳累比较严重时，他&#x2F;她往往做不出有效判断，无论是工作还是学习，都会比较吃力。 而如何有效生活，杜绝生活中在精神与心理上的消耗呢？看看下面五个生活日常，自己是否陷入了心理消耗之中，并对症下药进行自我调节。</p><h3 id="现象一-社恐"><a href="#现象一-社恐" class="headerlink" title="现象一:社恐"></a>现象一:社恐</h3><p>每次参加社交活动后，会一直思考自己什么地方没做对，别人在如何评价自己，过分紧张他人对自己的观点和看法，甚至会因为这些臆想中的评价感到难过、焦虑、悲伤。</p><p><strong>有效应对方法</strong></p><p>过于敏感和在意他人意见看法，源自个体自信心不足，这种低自尊状态，让你的内心十分不安，进而在无关紧要和并无确凿证据的事情上产生了强烈的内耗。请不要轻易低估自己，也不要对他人的评价毫不在意，而要以人无完人的态度，理性面对自己的优缺点，大方认可自己，并在他人评价的基础上正面完善自己。</p><h3 id="现象二-与别人比较"><a href="#现象二-与别人比较" class="headerlink" title="现象二:与别人比较"></a>现象二:与别人比较</h3><p>日常生活中，总是喜欢与他人进行比较与竞争。尤其是看到别人比自己优秀时，内心会产生强烈的不适感、失落感，甚至是嫉妒感。</p><p><strong>有效应对方法</strong></p><p>嫉妒和被嫉妒，都是人的正常情绪。当发现他人的优秀威胁到自己在资源分配中的优势地位时，人就会出现惧怕心理和嫉妒心理。但这种状态其实于事无补，因为无法改变的现实导致的嫉妒心理对人的内心耗损和伤害极大，一来它们不能让你变强大，二来只会使你一直把自己处在硬拼和逞能，以压倒对方的较劲状态下，进而在毫无意义的比较中心力交瘁。因此，当嫉妒来袭，你最应该做的就是平复心绪，找到对方的优点并与自己的优点做横向拆解与比较。当你对对方的优势有所了解和瓦解之后，再回头来看自己的独一无二之处，就能比较坦然地接纳对方的优秀，和自己暂时落后的处境。而这种心态上的缓和，将能使你集中有限的精力，去做大做强自己的优势。</p><h3 id="现象三-内心想变优秀，但是没有起色"><a href="#现象三-内心想变优秀，但是没有起色" class="headerlink" title="现象三:内心想变优秀，但是没有起色"></a>现象三:内心想变优秀，但是没有起色</h3><p>内心一直希望变优秀，而且思想也很活跃，但却毫无具体行动。实际上你只是思想勤奋，四肢懒惰而已，在默默跟自己较劲无数次后，因为现实毫无进展，进而感到沮丧而不知道原因。</p><p><strong>有效应对方法</strong></p><p>这是心理内耗最为典型的特征，身体不动，思想异常活跃。本质上，还是自身惰性在执掌自我的小乾坤，表现出来的就是执行力不足。所以，没别的，不要坐在原地等，做起来，干起来！当然，改变的过程是漫长的，很多人能坚持一个礼拜，但一看没有什么起色就放弃了，归根结底还是惰性在作祟。 我们不妨先从一些简单的地方开始改变。比如每天画个淡妆，但出门前喷个香水，把自己收拾的利利落落的。几分钟的时间你总有吧。 我就是从喷香水开始改变的，当时用的是春风十里的花词这款香水，用完身上会散发出淡淡的栀子花香，画个淡妆走在街上感觉自信了不少，偶尔还会有小姐姐来问我用的什么香水，交流一下感受，时间久了，把我社恐都治好了。</p><p>有了成功经验的指导，再去尝试别的改变就能更容易坚持下去了，像这样循序渐进，会变得越来越优秀。</p><h3 id="现象四-优柔寡断"><a href="#现象四-优柔寡断" class="headerlink" title="现象四:优柔寡断"></a>现象四:优柔寡断</h3><p>不敢做决定，总是优柔寡断，犹豫不决。甚至在选择之后，还会不断去思考自己的决定是否正确，想象当下不存在的失败和恐惧感。</p><p><strong>有效应对方法</strong></p><p>优柔寡断是内心割舍不清，没想清楚自己到底最想要什么，所以无法做出清晰确凿的决定和选择。此外就是压根没想去承担决策失败所造成的责任和痛苦，这是人格上的缺陷，造成的内心损耗。怎么改，得看自己到底是不是敢于舍弃和追求，想明白了，就行动，不要只是心动而行动上等于零。</p><h3 id="现象五-拖延"><a href="#现象五-拖延" class="headerlink" title="现象五:拖延"></a>现象五:拖延</h3><p>拖延，最常见的状况就是：往往不到最后一刻绝不动手，而且经常必须在压力之下才能做好一件事。并且，一边做一边拼命自责，而这种状态又特别影响正在做的事情，导致做了等于没做，效果极差。</p><p><strong>有效应对方法</strong></p><p>拖延心理产生的原因很庞杂，但无论是哪种原因，都请立即停止。哪怕是做得不好，也比拖到最后一刻才做要好得多，因为尚有时间补救。一定要谨记：凡事拖延，就会导致内心产生愧疚感和自我谴责，长期持续人就会产生自我否定的心理。所以，千万不要拖延！以上五个方面，大家可以自行对照检查，发现一个更改一个，尽量让自己的心理和精神状态处于健康和有序的氛围里。与此同时，要想减轻心理内耗，我们还要特别关注在某一个方面的有效积累，也就是我们在前文所提到的心理资源积累，它是减少内耗的重要因素！</p><p>感谢您的阅读，本文由 <a class="link"   href="https://www.zhihu.com/question/267653585/answer/1969255566" >可爱的小呆呆吖 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 原创提供。如若转载，请注明出处：可爱的小呆呆吖（<a class="link"   href="https://www.zhihu.com/question/267653585/answer/1969255566%EF%BC%89" >https://www.zhihu.com/question/267653585/answer/1969255566） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h2&gt;&lt;p&gt;真正厉害的人，都是“反内耗”体质，只有停止&lt;a class=&quot;link&quot;   href=&quot;https://www.zhihu.com/sea</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="内耗" scheme="http://example.com/tags/%E5%86%85%E8%80%97/"/>
    
  </entry>
  
  <entry>
    <title>我认知的电商在大促活动下的架构体系</title>
    <link href="http://example.com/2020/01/15/architecture/e-commerce-big-sale/"/>
    <id>http://example.com/2020/01/15/architecture/e-commerce-big-sale/</id>
    <published>2020-01-15T11:44:48.000Z</published>
    <updated>2023-11-17T11:37:37.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每到双 11、618 等大促月时，各大电商是如何应对海量并发请求的呢，今天总结归纳下这背后的技术架构体系，并列举出我们技术人员面临的一些挑战，如何克服解决。</p><h1 id="电商整体架构"><a href="#电商整体架构" class="headerlink" title="电商整体架构"></a>电商整体架构</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从组织架构到技术架构，当前各大电商系统基本趋于中台化。中台在2015由阿里提出，其实是一种企业 架构而不是单纯的技术层面，目前几乎各大电商都进行着中台化的建设。</p><p>中台没有什么神秘的，说到底，中台就是对 “共享”、“通用” 理念系统化的归纳和总结。</p><ul><li>重复功能建设和维护带来的重复投资 </li><li>烟囱式建设造成系统壁垒，数据孤岛 </li><li>业务沉淀促进可持续发展 </li><li>大中台小前台快速响应市场的需要</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://www.zhengyk.cn/images/2020-01-15-01.jpg"                      alt="image-20210318122506676"                ></p><h3 id="上层业务"><a href="#上层业务" class="headerlink" title="上层业务"></a>上层业务</h3><p>即大中台，小前台的前台，电商中直面用户的B2B,B2C等各个业务线。</p><h3 id="业务中台"><a href="#业务中台" class="headerlink" title="业务中台"></a>业务中台</h3><p>业务中台基于公共服务的沉淀，需要收敛一些基础的业务服务，如商品、订单、会员、库存、财务、结 算等等。</p><h3 id="数据中台"><a href="#数据中台" class="headerlink" title="数据中台"></a>数据中台</h3><p>数据中台不是一个平台，也不是一个系统。数据仓库、数据平台和数据中台是有区别的。简单的举例： 数据平台可以理解为数据库，数据仓库类比为报表，而数据中台更贴近上层业务，带着业务属性。</p><h3 id="技术中台"><a href="#技术中台" class="headerlink" title="技术中台"></a>技术中台</h3><p>与业务无关的基础沉淀，中间件，系统框架，监控，日志，集成部署等等</p><h3 id="运维中台"><a href="#运维中台" class="headerlink" title="运维中台"></a>运维中台</h3><p>不一定存在，系统运维相关的内容，硬件，机房，包括企业云平台的建设等可以划分为单独的运维中台</p><h2 id="面临挑战"><a href="#面临挑战" class="headerlink" title="面临挑战"></a>面临挑战</h2><ul><li>高性能：提供快速的访问体验。 </li><li>高可用：网站服务7*24正常访问。</li><li>可伸缩：硬件弹性增加&#x2F;减少能力（快速扩容与释放）。 </li><li>扩展性：方便地增加&#x2F;减少新的功能&#x2F;模块（迭代与服务降级）。 </li><li>安全性：安全访问和数据加密、安全存储等策略。 </li><li>敏捷性：快速应对突发情况的能力（灾备等）。</li></ul><h3 id="内部瓶颈"><a href="#内部瓶颈" class="headerlink" title="内部瓶颈"></a>内部瓶颈</h3><ul><li>木桶效应：水管最细的地方决定流量，水桶最低的地方决定容量（QPS压测调优为例） 。 </li><li>CPU：序列化和反序列化、高频日志输出、大量反射、大量线程的应用 。</li><li>内存：使用内存的中间件或服务，如redis，jvm大量对象堆积内存的应用等 。</li><li>带宽：大流量高并发环境下，用户访问量激增，造成网络拥堵 。</li><li>磁盘IO：文件上传下载，数据库频繁读写，不合理或大批量的日志输出。</li><li>数据库连接数：应用服务器连接池大批扩容，警惕底层数据库、Redis 等连接数瓶颈。</li></ul><h3 id="外部瓶颈"><a href="#外部瓶颈" class="headerlink" title="外部瓶颈"></a>外部瓶颈</h3><ul><li>短信：短信延迟与送达率问题， 可以搭建短信平台， 多家渠道做路由和切换分流。</li><li>支付：银行支付与回调延迟，搭建支付中心，对接多支付渠道。</li><li>快递：快递服务对接（快递100）。</li><li>外部云存储：文件访问、流量扩容。</li><li>CDN：静态文件采用  cdn 加速。</li></ul><p>外部云存储：云存储文件访问， 流量扩容（ 大家所使用的存储？nfs 的架构与事故） </p><p>CDN：外部静态文件访问提速服务（使用过的项目？）</p><h2 id="应对措施"><a href="#应对措施" class="headerlink" title="应对措施"></a>应对措施</h2><h3 id="订单中心"><a href="#订单中心" class="headerlink" title="订单中心"></a>订单中心</h3><h4 id="异步化"><a href="#异步化" class="headerlink" title="异步化"></a>异步化</h4><p>场景：订单状态变更时，实时同步到数据中台、大屏展示等。</p><p>问题：需要注意订单异步化引发的乱序问题，一是传输阶段，二是消费阶段。</p><p>示例：</p><ol><li><p>Rabbitmq ：可以在队列级保证顺序，单消费者消费一个队列可以严格保障顺序性，就是多一些 queue 而已；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p></li><li><p>Kafka：分区级别顺序保障，只能保障投放和传输阶段的顺序性，然后 一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。<br>写 N 个内存 queue，具有相同 订单 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</p></li></ol><h4 id="过期订单"><a href="#过期订单" class="headerlink" title="过期订单"></a>过期订单</h4><p>可以参考这篇：<a class="link"   href="https://zhengyk.cn/2019/05/01/mq/rabbitmq/cancel-expired-order/" >过期订单自动取消的几种实现方式 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="支付中心"><a href="#支付中心" class="headerlink" title="支付中心"></a>支付中心</h3><p>一般会有一个支付平台，由于我没完整做过支付，所以只列出常见支付的问题以及解决思路供参考：</p><h4 id="重复支付"><a href="#重复支付" class="headerlink" title="重复支付"></a>重复支付</h4><p>应对方案： </p><ul><li><p>前端程序屏蔽，前端js触发按钮置灰或者遮罩提示（支付成功？遇到问题？），或者在支付方式选择页直接 跳转。 </p></li><li><p>后端处理，发现不同通道下的支付成功回调，抛消息队列或记录日志。</p></li><li><p>数据修复： 首先查支付日志，确认针对同一笔订单收到了不同支付渠道的回调。</p><p> 其次，在支付平台管理后端可以查到入账记录，人工介入。 </p><p> 最后对账阶段会发现对方多帐，我方补单时出现重复订单。</p></li></ul><p>问题处理：</p><p>调取退款接口或者在支付渠道的管理后台操作退款（一定要多次确认无误）。</p><h4 id="异常订单"><a href="#异常订单" class="headerlink" title="异常订单"></a>异常订单</h4><h5 id="未收到支付成功"><a href="#未收到支付成功" class="headerlink" title="未收到支付成功"></a>未收到支付成功</h5><p>场景： 用户明明支付成功，但还是显示未成功</p><p> 问题分析： 一般支付渠道会间隔性多次回调支付成功链接，银行未回调的可能性比较小，着重排查开 单接口是否可用。如果可用追查日志是否出现异常记录。</p><p>应对措施：</p><p>订单支付结果查询：定时主动去查银行支付状态。</p><p>对账阶段可以查漏，程序自动完成补单，但是处理相对延迟。</p><h4 id="回调延迟"><a href="#回调延迟" class="headerlink" title="回调延迟"></a>回调延迟</h4><p>场景：用户是期望支付完成的同时立马看到结果。但是中间多层远程的调用，可能发生订单状态更新延迟问题。</p><p>解决： 主动查询。在用户查看订单的时候，如果是类似“支付中”的中间态时，触发远程订单状态查询接口。比如支付完成后，用户在界面点击“支付完成”时，触发单笔订单支付结果查询</p><h4 id="支付路由"><a href="#支付路由" class="headerlink" title="支付路由"></a>支付路由</h4><p>背景：</p><p>保障支付可用性及支付分流，支付中心对接多家渠道</p><p>方案：</p><ul><li>支付中心对接多个支付渠道，支付宝，微信，各银行或第三方支付供应商。 </li><li>对不同用户，进入支付方式选择页时，做支付分流。 </li><li>做好监控统计，一旦某个支付渠道不可用或者延迟较大，切掉，下线，或者降权。</li></ul><h3 id="营销中心"><a href="#营销中心" class="headerlink" title="营销中心"></a>营销中心</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>大促肯定伴随营销，一般营销中心所面对的主要是促销策略、优惠方式等业务上的架构问题。</p><p>营销活动：单品促销活动、套装促销活动、店铺促销活动，平台促销活动。</p><p>营销类型：满减、折扣、赠品、优惠券等。</p><p>业务复杂度高，一般遵循：“同类营销仅可选其一，不同类营销可叠加” 的规则。</p><h4 id="赠品设计"><a href="#赠品设计" class="headerlink" title="赠品设计"></a>赠品设计</h4><p>先了解 <a class="link"   href="https://www.zhihu.com/question/29073730" >SPU、SKU 的基础概念 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>赠品有两种设计方案，一种是不做单独的SKU，只有一个空的描述，设计简单，缺点是没有商品详情 页，无法给用户直观的查看和估值。</p><p>另一种是单独做SKU，赠品也会作为一个商品存在，与主商品关联，下单的时候将会自动加到商品列 表，价格降为0。这种更为常见。整个商品有完善的详情页，用户可以直接看到价格甚至单独下单购 买。</p><h4 id="排他与优先级"><a href="#排他与优先级" class="headerlink" title="排他与优先级"></a>排他与优先级</h4><p>检查同类别促销，将最大优惠力度的规则应用到订单，并且满足排他性，同类只享受其一。比如满10减 3，满20减5，那么用户购买大于20时，只减5即可。</p><p>不同类别不做排斥，如购物车整体满减后，不影响单个商品的折扣。在记录数据时，优惠要细化到每个 单独的订单明细上。退款也做到明细级别的单独退。</p><h4 id="价格分摊"><a href="#价格分摊" class="headerlink" title="价格分摊"></a>价格分摊</h4><p>满减或平台券等优惠，在多个商品下单时，涉及到金额的分摊。即 优惠总额度&#x2F;购物车总额 ，得到比例 后再按比例均分到每个商品。只有分摊才能在发生部分退款时退回真实金额。</p><p>但是这会涉及到一个精度问题。举例如下：满99减9活动，假设用户购买了 30+40+50&#x3D;120，3件商品 应付111元。按比例折算的话，9&#x2F;99取4位小数是0.9090，那么分摊后为 30x0.9090+40x0.9090+50x0.9090&#x3D;109.08与实际支付金额出现偏差。这会造成财务无法平账。</p><p>解决方案：记账时在订单明细记录，将误差 111-109.08&#x3D;1.92计入金额最大的明细，也就是50元商品 上。那么最终记账为：30x0.9090 + 40x0.9090 +（50*0.909+1.92）&#x3D; 111</p><h4 id="退单处理"><a href="#退单处理" class="headerlink" title="退单处理"></a>退单处理</h4><p>退单后要同时恢复用户的权益，比如优惠券的再次使用，限购次数等。确保用户体验。</p><h4 id="商品中心"><a href="#商品中心" class="headerlink" title="商品中心"></a>商品中心</h4><ol><li><p>限时商品下架控制：这个和过期订单自动取消的技术手段一样，不再赘述。</p></li><li><p>库存管理：</p><blockquote><p>普通商品可以直接借助数据库锁实现，一般分乐观锁和悲观锁两种方案，如果采用悲观锁（如select语 句带forupdate）， 会带来很大的性能阻塞， 所以更多的采用乐观锁设计。 </p><p>乐观锁就是在最后执行库存扣减操作时，将事务开始前获取的库存数量带入到SQL语句中作为更新的 where条件，如果数量相等，则该条更新库存的语句成功执行返回update条数为1；如果不相等，则表 示该商品的库存信息已经被其他事务修改，需要放弃该条update的执行，采用重试处理。</p><p>库存秒杀商品因为大批量的访问在一瞬间涌入，数据库扛不住。可以采用 redis缓存做decr处理，正常</p><p>下单后，再使用mq异步更新到db。</p></blockquote></li></ol><h2 id="技术中台-1"><a href="#技术中台-1" class="headerlink" title="技术中台"></a>技术中台</h2><h3 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h3><p>数据库层的调优一般发生在大促之前的预备阶段，大促开始后再优化已经来不及了。</p><p>总结下主要有几点：</p><blockquote><ol><li><p>在大促开始前梳理耗时查询业务，对关键业务压测。</p></li><li><p>开启mysql的慢查询日志（两种方式）</p><div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置文件方式，需要重启mysql </span></span><br><span class="line"><span class="comment">#日志文件位置 </span></span><br><span class="line"><span class="attr">log-slow-queries</span>=<span class="string">/opt/data/slowquery.log </span></span><br><span class="line"><span class="comment">#超时时间，默认10s long_query_time=2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#临时开启，不需要重启</span></span><br><span class="line"><span class="attr">set</span> <span class="string">global slow_query_log=on;</span></span><br><span class="line"><span class="attr">set</span> <span class="string">global long_query_time=2;</span></span><br><span class="line"><span class="attr">set</span> <span class="string">global slow_query_log_file=‘/opt/data/slow_query.log’;</span></span><br></pre></td></tr></table></figure></div></li><li><p>借助 explain查看sql执行计划，对sql调优。</p></li></ol></blockquote><h3 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h3><h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><ol><li>热数据预热：常规缓存设计趋向于懒加载，大促期间的热点数据尽量做到预热加载。比如某个促销专题，不要等待活 动开始的一瞬间再读库加缓存，搞不好引发击穿。</li><li><strong>细粒度设计</strong>：集合与单体分开存储，缓存结构细粒度化。如某个推荐商品列表，常规存储一个key，value为整个商品集合。优化为列表与每个商品详细信息设置两个独立缓存值，在查询环节组装。新增一个推荐则失效列表，修改商品则仅仅失效当前商品缓存。这样做的好处是缓存存储颗粒度变小，当数据库修改时可以降低缓存的修改冲击。</li><li>可用性：缓存穿透、缓存雪崩等。</li></ol><h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h4><p>优化缓存体系，对关键业务请求，如商品详情页，采用多级缓存处理</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://www.zhengyk.cn/images/2020-01-15-02.jpg?a=1"                                     ></p><h3 id="分流与限流"><a href="#分流与限流" class="headerlink" title="分流与限流"></a>分流与限流</h3><p>CDN的引入本身起到了按ip分流的作用，但是我们可以在下层做到更细粒度化的控制。根据业务情况将 不同的请求分流到各自的服务器。</p><p>限流是 当系统超过一定流量后，超过的流量做直接拒绝处理，以便保护后 端的服务，原则就是要么不进来，进来的都正常服务。常见的限流算法有这几种：滑动窗口、计数器、漏桶、令牌桶。</p><p>限流算法参考此篇：<a class="link"   href="https://zhengyk.cn/2018/09/16/framework/limit-degrade/" >降级与限流 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h4 id="业务分流"><a href="#业务分流" class="headerlink" title="业务分流"></a>业务分流</h4><p>根据不同的业务线分发请求，配备二级域名如b2b.xxx.com，b2c.xxx.com，或者在nginx软负载层针对 不同虚拟主机名做upstream分发</p><p>大促期的活动页，或者促销专题页面，采用新访问入口和机器部署，与主站分离。活动结束后也利于 机器资源的快速释放。</p><h4 id="终端分流"><a href="#终端分流" class="headerlink" title="终端分流"></a>终端分流</h4><p>按不同的请求终端分流，在header头的user-agent中可以捕获用户的访问终端。android，ios，pc， 根据不同终端设备，做流量分发，到不同的应用机器。同时方便对用户终端流量的监控和统计。</p><h4 id="nginx限流"><a href="#nginx限流" class="headerlink" title="nginx限流"></a>nginx限流</h4><p>Nginx中使用 ngx_http_limit_req_module 模块来限制请求的访问频率，基于漏桶算法原理实现。</p><h4 id="网关限流"><a href="#网关限流" class="headerlink" title="网关限流"></a>网关限流</h4><p>从代理服务器放进来的流量，会进入应用服务器，第一道关卡是微服务的网关。应对大促，针对各个微 服务具体业务具体分析，配备对应限流措施。zuul和springcloud gateway是团队中最常遇到的网关组件。</p><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单 的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。是一种舍车保帅的策略。</p><p>比如平时客户来我的店铺购买衣服。平时可以试穿，给出建议，帮助搭配，最后下单支付，送用户祝福 卡片等。双11大促则简单粗暴响应下单支付收钱发货。其他不太重要的服务关闭开关，腾出资源让位主 交易流程。</p><p>服务降级可以从前端页面，后端微服务两个点着手。</p><h4 id="页面降级"><a href="#页面降级" class="headerlink" title="页面降级"></a>页面降级</h4><p>很好理解，针对页面元素处理，将不重要的操作入口置灰或屏蔽。平时调用后端接口实时呈现数据的地 方替换为静态页也可以理解为一种降级操作。</p><h4 id="微服务降级"><a href="#微服务降级" class="headerlink" title="微服务降级"></a>微服务降级</h4><p>配置接口开关，并通过配置中心可以灵活开闭。必要时关闭开关，屏蔽接口的实际查询，直接返回 mock数据。</p><h4 id="快速熔断"><a href="#快速熔断" class="headerlink" title="快速熔断"></a>快速熔断</h4><p>快速熔断可以认为是在应对突发情况时，对服务请求结果准确性的一种妥协。避免因单一服务垮台导致 整个调用链路崩溃。常用手段如下：</p><p>抛异常：这种处理需要上层配备异常处理机制，在捕获异常时，导向错误页、等待页或稍后重试 等。 返回NULL：简单粗暴，可能会出现空白结果，并不友好。 调用Fallback处理逻辑：更人性化的手段，也最常用。为每个业务配备一个备选方案。</p><p>举个例子：商品页或订单详情页面，一般都会有猜你喜欢这个模块，通过对用户的购买行为、浏览记录、收藏记录等等进行大数据分析，然后给每一个用户推送自己可能喜欢的商品。在双11大促背景下， 如果推荐服务压力过大，出现服务出错、网络延迟等等之类突发情况，导致最后调用服务失败，则可以 配备一个fallback，直接返回当前商品同类别下的几款商品，作为备选方案，这比抛异常或者返回null空 白页面体验要更优。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>大促前做好安全防范。常见的DDos，Arp，脚本等攻击平时也会存在，日常防范已经配备。大促期间需 要注意的可能更多的是业务层面的入侵，比如抢购或秒杀时的恶意刷接口。</p><p>实名制，限制单用户，单ip等维度下的频次 </p><p>必要的地方添加验证码（图片复杂度升级，或滑块等新型方式） </p><p>黑名单机制，一旦发现恶意行为，列入黑名单，并自动维护</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;每到双 11、618 等大促月时，各大电商是如何应对海量并发请求的呢，今天总结归纳下这背后的技术架构体系，并列举出我们技术人员面临的一些挑战</summary>
      
    
    
    
    <category term="架构" scheme="http://example.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://example.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 使用 reindex 快速修改生产环境索引 mapping</title>
    <link href="http://example.com/2019/11/30/elasticsearch/es-reindex/"/>
    <id>http://example.com/2019/11/30/elasticsearch/es-reindex/</id>
    <published>2019-11-30T11:44:48.000Z</published>
    <updated>2023-11-17T11:37:37.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正常情况下，在使用 elasticsearch 之前就应该把 mapping 指定写好。但特殊情况下，索引的 mapping 必须修改，比如一开始指定的 mapping 不合理，或者当有程序意外将原先 mapping 污染的时候等等。</p><p>现生产环境有一个索引 order mapping 因为业务规则更改而必须修改，但是索引中已经存在几个 G 的数据，如果删除索引重新创建 mapping 再重新导入数据太耗时（实测速度大概是bulk导入数据的5-10倍），所以采用 ES reindex 和 alias 的方式来操作。</p><p>建议在没有操作 es 目标索引的窗口期执行（我们的这个 es 索引是通过 canal 监听 binlog 同步到 es 的，并且我在配置中心里设置了canal client 端是否消费 canal 服务端 binlog 的开关，这里直接在窗口期将此开关关闭，待操作完成后再打开开关，自动消费堆积的 binlog 即可，不影响数据库与 es 数据一致性）</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>创建新的订单索引 order-v2，并为其创建新的正确的 mapping。</li><li>使用 reindex 将索引 order 数据迁移到 order-v2 上。</li></ol><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;order&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">5000</span> <span class="comment">// reindex batch size:根据数据量和机器性能，自己调整</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;order-v2&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><ol start="3"><li>控制台 删除原先 order 索引。</li><li>控制台 将 order-v2  索引命名别名 “order” ， 或者 使用 restful 请求将 3，4 步骤合并：</li></ol><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST _aliases</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;actions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;add&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;order-v2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;alias&quot;</span><span class="punctuation">:</span> <span class="string">&quot;order&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;remove_index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;order&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><p>操作完成。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>使用 reindex 和 alias 可以让数据平滑迁移，不需要修改代码且用户无感知。</p><p>当我们对 es 进行了扩容，原先索引创建的分片、副本不足，导致数据入库、查询较慢，需要扩大 es 的分片、副本数量时，也可以用 ES Reindex。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;正常情况下，在使用 elasticsearch 之前就应该把 mapping 指定写好。但特殊情况下，索引的 mapping 必须修改，比如</summary>
      
    
    
    
    <category term="搜索引擎" scheme="http://example.com/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>记录项目中 spring 事务与分布式锁使用不当的 bug</title>
    <link href="http://example.com/2019/11/11/project/tx-distributedLock/"/>
    <id>http://example.com/2019/11/11/project/tx-distributedLock/</id>
    <published>2019-11-11T06:48:33.000Z</published>
    <updated>2023-11-17T11:37:37.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>在当前项目中做了一个电子钱包功能，在操作电子钱包的业务中，要更新多张表数据，且存在并发操作钱包金额的情况，为了保证数据一致性且并发操作钱包金额都能成功，采用了事务+分布式锁的方式。</p><p>大致代码如下：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operateEwallet</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 加锁</span></span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 执行操作电子钱包的业务代码 先查询后更新</span></span><br><span class="line">       ...</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><p>但是这样的代码在经过 jmeter 压测后，发现金额总是对不上。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在上述代码中，先开启事务，再在事务中使用了 redis 分布式锁，防止并发问题，仔细分析后发现这是有问题的，在事务内开启锁，并发的请求会阻塞在事务内部，假如 A，B 两个请求同时过来，A 先开启事务获得锁，查询数据再操作完数据后，释放锁，但此时事务还没提交，B 获得锁，B 再查询的数据是 A 未提交的数据，所以数据肯定不一致。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>将开启分布式锁的代码放在事务外部，比如放在 controller 层</p><p>再次用 jmeter 多次压测，发现数据一致，问题解决。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题现象&quot;&gt;&lt;a href=&quot;#问题现象&quot; class=&quot;headerlink&quot; title=&quot;问题现象&quot;&gt;&lt;/a&gt;问题现象&lt;/h2&gt;&lt;p&gt;在当前项目中做了一个电子钱包功能，在操作电子钱包的业务中，要更新多张表数据，且存在并发操作钱包金额的情况，为了保证数据一致性</summary>
      
    
    
    
    <category term="项目实战" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="spring事务" scheme="http://example.com/tags/spring%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>一个基于 Docker 快速构建 redis 集群的小工具</title>
    <link href="http://example.com/2019/10/10/redis/simple-build-redis-cluster-tool/"/>
    <id>http://example.com/2019/10/10/redis/simple-build-redis-cluster-tool/</id>
    <published>2019-10-10T08:39:03.000Z</published>
    <updated>2023-11-17T11:37:37.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我在学习或者测试时，可能会用到 redis-cluster 环境，但当时手头没有的话得现搭，过程比较麻烦，所以搞了个 基于 Docker 快速构建 redis 集群的小工具。</p><p>集群原理就不赘述了，直接开始。</p><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><blockquote><p>CentOS 8</p><p>Docker 19.03.13</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>在 ~&#x2F; 下创建 redis-cluster 目录</p><p>cd ~&#x2F;redis-cluster</p><h3 id="1-安装-docker-略"><a href="#1-安装-docker-略" class="headerlink" title="1. 安装 docker 略"></a>1. 安装 docker 略</h3><p>关闭防火墙再启动 docker</p><h3 id="2-下载-redis-镜像"><a href="#2-下载-redis-镜像" class="headerlink" title="2 下载 redis 镜像"></a>2 下载 redis 镜像</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure></div><h3 id="3-docker-创建虚拟网卡"><a href="#3-docker-创建虚拟网卡" class="headerlink" title="3 docker 创建虚拟网卡"></a>3 docker 创建虚拟网卡</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create redis-net</span><br></pre></td></tr></table></figure></div><p>因为redis 各容器节点要互相通信，且要与外界通信，所以选择 docker 的桥接模式，docker 虚拟网卡默认的就是桥接模式</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://www.zhengyk.cn/images/2020-10-24-1.jpg"                      alt="image-20201025123854561"                ></p><h3 id="4-创建-redis-集群通用配置模板"><a href="#4-创建-redis-集群通用配置模板" class="headerlink" title="4 创建 redis 集群通用配置模板"></a>4 创建 redis 集群通用配置模板</h3><p>vim redis-cluster-tmp.conf</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">端口</span> </span><br><span class="line">port $&#123;PORT&#125; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">非保护模式</span> </span><br><span class="line">protected-mode no </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启用集群模式</span> </span><br><span class="line">cluster-enabled yes </span><br><span class="line">cluster-config-file nodes.conf </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">超时时间</span> </span><br><span class="line">cluster-node-timeout 5000 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">集群各节点IP地址  宿主机 IP</span></span><br><span class="line">cluster-announce-ip 192.168.1.10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">集群节点映射端口</span> </span><br><span class="line">cluster-announce-port $&#123;PORT&#125; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">集群总线端口</span> </span><br><span class="line">cluster-announce-bus-port 1$&#123;PORT&#125; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启aof持久化策略</span> </span><br><span class="line">appendonly yes </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">后台运行 docker 使用配置文件启动，这里一定要为 no, 或者注释掉，不能为 <span class="built_in">yes</span></span></span><br><span class="line">daemonize no </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进程号存储</span> </span><br><span class="line">pidfile /var/run/redis_$&#123;PORT&#125;.pid </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">集群加密</span> </span><br><span class="line">masterauth zhengyk </span><br><span class="line">requirepass zhengyk</span><br></pre></td></tr></table></figure></div><h3 id="4-创建-用-docker-构建-redis-的脚本-start-redis-cluster-sh"><a href="#4-创建-用-docker-构建-redis-的脚本-start-redis-cluster-sh" class="headerlink" title="4.创建 用 docker 构建 redis  的脚本:  start-redis-cluster.sh"></a>4.创建 用 docker 构建 redis  的脚本:  start-redis-cluster.sh</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在~/redis-cluster下生成conf和data目标，并生成配置信息</span></span><br><span class="line"></span><br><span class="line">for port in `seq 7002 7007`; </span><br><span class="line">do</span><br><span class="line">mkdir -p ./$&#123;port&#125;/conf &amp;&amp; PORT=$&#123;port&#125; envsubst &lt; ./redis-cluster-tmp.conf &gt; ./$&#123;port&#125;/conf/redis.conf &amp;&amp; mkdir -p ./$&#123;port&#125;/data; </span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建6个redis容器</span> </span><br><span class="line">for port in `seq 7002 7007`; </span><br><span class="line">do</span><br><span class="line">docker run -d -it -p $&#123;port&#125;:$&#123;port&#125; -p 1$&#123;port&#125;:1$&#123;port&#125; -v ~/redis-cluster/$&#123;port&#125;/conf/redis.conf:/usr/local/etc/redis/redis.conf -v ~/redis-cluster/$&#123;port&#125;/data:/data --privileged=true --restart always --name redis-$&#123;port&#125; --net redis-net --sysctl net.core.somaxconn=1024 redis redis-server /usr/local/etc/redis/redis.conf;</span><br><span class="line">done </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打印出 docker 各个 redis ip</span> </span><br><span class="line">for port in `seq 7002 7007`;</span><br><span class="line">do</span><br><span class="line">echo -n &quot;$(docker inspect --format &#x27;&#123;&#123; (index .NetworkSettings.Networks &quot;redis-net&quot;).IPAddress &#125;&#125;&#x27; &quot;redis-$&#123;port&#125;&quot;)&quot;:$&#123;port&#125;&quot; &quot;; </span><br><span class="line">done</span><br></pre></td></tr></table></figure></div><h3 id="5-授予-start-redis-cluster-sh-可执行权限并执行该脚本"><a href="#5-授予-start-redis-cluster-sh-可执行权限并执行该脚本" class="headerlink" title="5 授予 start-redis-cluster.sh 可执行权限并执行该脚本"></a>5 授予 start-redis-cluster.sh 可执行权限并执行该脚本</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 start-redis-cluster.sh</span><br><span class="line">./start-redis-cluster.sh</span><br></pre></td></tr></table></figure></div><p>控制台打印:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://www.zhengyk.cn/images/2020-10-24-2.jpg"                      alt="image-20201025124949005"                ></p><p>红框内的地址就是 我们创建的 6 台 redis 节点, 查看容器运行信息</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://www.zhengyk.cn/images/2020-10-24-4.jpg"                      alt="image-20201025130945551"                ></p><h3 id="6-将-6个redis-节点加入到集群中"><a href="#6-将-6个redis-节点加入到集群中" class="headerlink" title="6 将 6个redis 节点加入到集群中"></a>6 将 6个redis 节点加入到集群中</h3><p>进入到任意一个安装好的redis节点的bin目录，里面有个脚本对象 redis-cli ，然后执行集群创建</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-7002 /bin/bash</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在容器内部</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-a zhengyk 是前面配置文件里的集群认证密码, -cluster-replicas 1 表示每个主节点有 1 个从节点</span></span><br><span class="line">./usr/local/bin/redis-cli --cluster create 172.18.0.2:7002 172.18.0.3:7003 172.18.0.4:7004 172.18.0.5:7005 172.18.0.6:7006 172.18.0.7:7007 --cluster-replicas 1 -a zhengyk</span><br></pre></td></tr></table></figure></div><p>输入 yes ，redis 集群会自动分配 slot， 控制台打印</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://www.zhengyk.cn/images/2020-10-24-3.jpg"                      alt="image-20201025130220120"                ></p><p> 这样我们就基于 docker 快速创建了 一个 3 主 3 从的 redis 集群。</p><h3 id="7-停止集群的脚本-stop-redis-cluster-sh"><a href="#7-停止集群的脚本-stop-redis-cluster-sh" class="headerlink" title="7 停止集群的脚本 stop-redis-cluster.sh"></a>7 停止集群的脚本 stop-redis-cluster.sh</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line">docker stop redis-7002 redis-7003 redis-7004 redis-7005 redis-7006 redis-7007 </span><br><span class="line">docker rm redis-7002 redis-7003 redis-7004 redis-7005 redis-7006 redis-7007 </span><br><span class="line">rm -rf 7002 7003 7004 7005 7006 7007</span><br></pre></td></tr></table></figure></div><p>最后附上所需的 配置文件和 启动、停止集群的脚本</p><p><a class="link"   href="http://media.ithuskie.com/redis-cluster-tmp.conf" >redis-cluster-tmp.conf <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link"   href="http://media.ithuskie.com/start-redis-cluster.sh?a=1" >start-redis-cluster.sh <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><a class="link"   href="http://media.ithuskie.com/stop-redis-cluster.sh" >stop-redis-cluster.sh <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我在学习或者测试时，可能会用到 redis-cluster 环境，但当时手头没有的话得现搭，过程比较麻烦，所以搞了个 基于 Docker 快</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch使用优化之拙见（转）</title>
    <link href="http://example.com/2019/09/04/elasticsearch/es-optimized/"/>
    <id>http://example.com/2019/09/04/elasticsearch/es-optimized/</id>
    <published>2019-09-04T11:44:48.000Z</published>
    <updated>2023-11-17T11:37:37.429Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch常常作为日志存储和分析的工具，在企业级应用中常常使用。Elasticsearch提供强大的搜索、分析功能，已经是后端技术栈不可缺少的一部分。 在维护ElastciSearch集群的时候，对Elasticsearch进行了一些调优和分析，现整理成文，纯属拙见，如果有不合理之处，欢迎指出探讨。我所使用的Elasticsearch版本为5.x。</p><h2 id="文件句柄优化"><a href="#文件句柄优化" class="headerlink" title="文件句柄优化"></a>文件句柄优化</h2><p>Elasticsearch有大量的查询数据和插入数据的请求，需要大量文件句柄，centos系统默认的1024个文件句柄。如果文件句柄用完了，这就意味着操作系统会拒绝连接，意味着数据可能丢失，这是灾难性的后果， 不能被接受。登陆Elasticsearch的启动用户，用一下命令查看：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure></div><p>查看结果：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 127673</span><br><span class="line">max locked memory       (kbytes, -l) unlimited</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 2056474</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure></div><p>上面的文件句柄（open files）的个数为1024，在ElasticSearch大量请求的情况下，这个句柄数量是不够的，可以改成655360。</p><p>临时修改可以通过执行以下命令，即可立即生效，但是机器重启后又会失效：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 655360</span><br></pre></td></tr></table></figure></div><p>永久生效，修改&#x2F;etc&#x2F;security&#x2F;limits.conf，需要重启机器生效：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u_es - nofile 655360</span><br></pre></td></tr></table></figure></div><p>上述配置中u_es为启动ElasticSearch的用户，设置了该用户的ElasticSearch的文件句柄为655360、</p><h2 id="JVM参数优化"><a href="#JVM参数优化" class="headerlink" title="JVM参数优化"></a>JVM参数优化</h2><p>Elasticsearch是运行在JVM上的，对其做JVM参数调优至关重要。最常见的调优是Java内存的分配。下面是JVM的内存模型，具体每块的作用，不在这里阐述。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://www.fangzhipeng.com/img/jianshu/2279594-3b2b0bc71f17ad37.png"                      alt="img"                ></p><h3 id="新生代和老年代分配的内存比例给多大？"><a href="#新生代和老年代分配的内存比例给多大？" class="headerlink" title="新生代和老年代分配的内存比例给多大？"></a>新生代和老年代分配的内存比例给多大？</h3><p>Jvm内存分为新生代和老年代。</p><ul><li>新生代（或者伊甸园） 新实例化的对象分配的空间。新生代空间通常都非常小，一般在 100 MB–500 MB。新生代也包含两个 幸存 空间。</li><li>老年代 较老的对象存储的空间。这些对象预计将长期留存并持续上很长一段时间。老生代通常比新生代大很多。</li></ul><p>新生代、老生代的垃圾回收都有一个阶段会“stop the world”。在这段时间里，JVM 停止了程序运行，以便对对象进行可达性分析，收集死亡对象。在这个时间停止阶段，一切都不会发生。请求不被服务，ping 不被回应，分片不被分配。整个世界都真的停止了。 对于新生代，这不是什么大问题；那么小的空间意味着 GC 会很快执行完。但是老生代大很多，而这里面一个慢 GC 可能就意味着 1 秒乃至 15 秒的暂停——对于服务器软件来说这是不可接受的。</p><p>那一般我们给新生代和老年代分配多大的内存呢？他们的比例是多少呢？ 一般来说，老年代和新生代的内存比例为2：1是比较合适的。比如给堆内存分配3G，则新生代分配1G，其余都给老年代。在ElasticSearce的配置文件jvm.options文件配置：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xms3g  //配置堆初始化大小</span><br><span class="line">-Xmx3g   //配置堆的最大内存</span><br><span class="line">-Xmn1g   //配置新生代内存。</span><br></pre></td></tr></table></figure></div><h3 id="该分配多大的内存给Elasticesearch？"><a href="#该分配多大的内存给Elasticesearch？" class="headerlink" title="该分配多大的内存给Elasticesearch？"></a>该分配多大的内存给Elasticesearch？</h3><p>在使用Elasticesearch的时候，我们对装Elasticesearch的机器进行了升级，从最小的8G内存升级到了16G内存，然后到目前的32G内存。一台机器装一个Elasticesearch节点，我们应该怎么分配机器的内存呢？ 官方给出了解决方案，把一半（少于）的内存分配给Luence，另外的内存分配给ElasticSearch.</p><p>内存对于 Elasticsearch 来说绝对是重要的，它可以被许多内存数据结构使用来提供更快的操作。但是说到这里， 还有另外一个内存消耗大户 非堆内存 （off-heap）：Lucene。</p><p>Lucene 被设计为可以利用操作系统底层机制来缓存内存数据结构。 Lucene 的段是分别存储到单个文件中的。因为段是不可变的，这些文件也都不会变化，这是对缓存友好的，同时操作系统也会把这些段文件缓存起来，以便更快的访问。</p><p>Lucene 的性能取决于和操作系统的相互作用。如果你把所有的内存都分配给 Elasticsearch 的堆内存，那将不会有剩余的内存交给 Lucene。 这将严重地影响全文检索的性能。</p><p>标准的建议是把 50％ 的可用内存作为 Elasticsearch 的堆内存，保留剩下的 50％。当然它也不会被浪费，Lucene 会很乐意利用起余下的内存。</p><p>我们实际的解决办法是将机器的一半分给Elasticesearch的堆，栈内存、方法区、常量池、非堆内存占用另外一半。</p><h3 id="分配给堆最大内存应该小于-32766-mb（-31-99-gb）"><a href="#分配给堆最大内存应该小于-32766-mb（-31-99-gb）" class="headerlink" title="分配给堆最大内存应该小于 32766 mb（~31.99 gb）"></a>分配给堆最大内存应该小于 32766 mb（~31.99 gb）</h3><p>JVM 在内存小于 32 GB 的时候会采用一个内存对象指针压缩技术。 对于 32 位的系统，意味着堆内存大小最大为 4 GB。对于 64 位的系统， 可以使用更大的内存，但是 64 位的指针意味着更大的浪费，因为你的指针本身大了。更糟糕的是， 更大的指针在主内存和各级缓存（例如 LLC，L1 等）之间移动数据的时候，会占用更多的带宽。 Java 使用一个叫作 内存指针压缩（compressed oops）的技术来解决这个问题。 它的指针不再表示对象在内存中的精确位置，而是表示 偏移量 。这意味着 32 位的指针可以引用 40 亿个 对象 ， 而不是 40 亿个字节。最终， 也就是说堆内存增长到 32 GB 的物理内存，也可以用 32 位的指针表示。 一旦你越过那个神奇的 ~32 GB 的边界，指针就会切回普通对象的指针。 每个对象的指针都变长了，就会使用更多的 CPU 内存带宽，也就是说你实际上失去了更多的内存。事实上，当内存到达 40–50 GB 的时候，有效内存才相当于使用内存对象指针压缩技术时候的 32 GB 内存。 这段描述的意思就是说：即便你有足够的内存，也尽量不要 超过 32 GB。因为它浪费了内存，降低了 CPU 的性能，还要让 GC 应对大内存。</p><h2 id="关掉swap"><a href="#关掉swap" class="headerlink" title="关掉swap"></a>关掉swap</h2><p>内存交换 到磁盘对服务器性能来说是 致命 的。</p><p>如果内存交换到磁盘上，一个 100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起来。 不难看出 swapping 对于性能是多么可怕。</p><p>用以下命令关掉swap:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo swapoff -a</span><br></pre></td></tr></table></figure></div><h2 id="不要碰以下的配置"><a href="#不要碰以下的配置" class="headerlink" title="不要碰以下的配置"></a>不要碰以下的配置</h2><p>所有的调整就是为了优化，但是这些调整，你真的不需要理会它。因为它们经常会被乱用，从而造成系统的不稳定或者糟糕的性能，甚至两者都有可能。</p><h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><p>许多人 喜欢 调整线程池。 无论什么原因，人们都对增加线程数无法抵抗。索引太多了？增加线程！搜索太多了？增加线程！节点空闲率低于 95％？增加线程！ Elasticsearch 默认的线程设置已经是很合理的了。对于所有的线程池（除了 搜索 ），线程个数是根据 CPU 核心数设置的。 如果你有 8 个核，你可以同时运行的只有 8 个线程，只分配 8 个线程给任何特定的线程池是有道理的。 搜索线程池设置的大一点，配置为 int（（ 核心数 ＊ 3 ）／ 2 ）＋ 1 。</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>Elasticsearch 默认的垃圾回收器（ GC ）是 CMS。 这个垃圾回收器可以和应用并行处理，以便它可以最小化停顿。 然而，它有两个 stop-the-world 阶段，处理大内存也有点吃力。</p><p>尽管有这些缺点，它还是目前对于像 Elasticsearch 这样低延迟需求软件的最佳垃圾回收器。官方建议使用 CMS。</p><h2 id="合理设置最小主节点"><a href="#合理设置最小主节点" class="headerlink" title="合理设置最小主节点"></a>合理设置最小主节点</h2><p>minimum_master_nodes 设置及其重要，为了防止集群脑裂，这个参数应该设置为法定个数就是 ( master 候选节点个数 &#x2F; 2) + 1。</p><p><strong>注：在 7.x 版本中会自动配置，不需要手动配置此设置</strong></p><h2 id="分片均匀，磁盘优化，剔除掉高负载的Master竞选？"><a href="#分片均匀，磁盘优化，剔除掉高负载的Master竞选？" class="headerlink" title="分片均匀，磁盘优化，剔除掉高负载的Master竞选？"></a>分片均匀，磁盘优化，剔除掉高负载的Master竞选？</h2><p>笔者在实际生产环境中遇到了有一个节点的负载是其他节点的几倍，从虚拟机监控上看，所有的节点的qps是差不多的。机器的配置是一样的，为什么负载会有如此大的差距？</p><ul><li>首先，我们怀疑数据分配不均匀，我们排查了下，没有这种现象。</li><li>然后，我们监控到了高负载的节点磁盘IO非常的高，经常达到100%，我们怀疑是那个虚拟机磁盘性能不行。但是我们当时没有更好的磁盘。</li><li>我们找到了一个适中的解决办法是将这台高负载的节点剔除Master竞选，即将elasticsearch.yml文件中的node.master改为false然后重启，负载下降了一些。</li></ul><h2 id="数据存储天数的优化"><a href="#数据存储天数的优化" class="headerlink" title="数据存储天数的优化"></a>数据存储天数的优化</h2><p>存储天数的优化，这个需要根据实际的业务来，下面是删除过期数据的脚本，该脚本来源于<a class="link"   href="https://stackoverflow.com/questions/33430055/removing-old-indices-in-elasticsearch#answer-39746705" >https://stackoverflow.com/questions/33430055/removing-old-indices-in-elasticsearch#answer-39746705 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ；</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">searchIndex=logstash-monitor</span><br><span class="line">elastic_url=logging.core.k94.kvk.nl</span><br><span class="line">elastic_port=9200</span><br><span class="line"></span><br><span class="line">date2stamp () &#123;</span><br><span class="line">    date --utc --date &quot;$1&quot; +%s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dateDiff ()&#123;</span><br><span class="line">    case $1 in</span><br><span class="line">        -s)   sec=1;      shift;;</span><br><span class="line">        -m)   sec=60;     shift;;</span><br><span class="line">        -h)   sec=3600;   shift;;</span><br><span class="line">        -d)   sec=86400;  shift;;</span><br><span class="line">        *)    sec=86400;;</span><br><span class="line">    esac</span><br><span class="line">    dte1=$(date2stamp $1)</span><br><span class="line">    dte2=$(date2stamp $2)</span><br><span class="line">    diffSec=$((dte2-dte1))</span><br><span class="line">    if ((diffSec &lt; 0)); then abs=-1; else abs=1; fi</span><br><span class="line">    echo $((diffSec/sec*abs))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for index in $(curl -s &quot;$&#123;elastic_url&#125;:$&#123;elastic_port&#125;/_cat/indices?v&quot; |     grep -E &quot; $&#123;searchIndex&#125;-20[0-9][0-9]\.[0-1][0-9]\.[0-3][0-9]&quot; | awk &#x27;&#123;     print $3 &#125;&#x27;); do</span><br><span class="line">  date=$(echo $&#123;index: -10&#125; | sed &#x27;s/\./-/g&#x27;)</span><br><span class="line">  cond=$(date +%Y-%m-%d)</span><br><span class="line">  diff=$(dateDiff -d $date $cond)</span><br><span class="line">  echo -n &quot;$&#123;index&#125; ($&#123;diff&#125;)&quot;</span><br><span class="line">  if [ $diff -gt 1 ]; then</span><br><span class="line">    echo &quot; / DELETE&quot;</span><br><span class="line">    # curl -XDELETE &quot;$&#123;elastic_url&#125;:$&#123;elastic_port&#125;/$&#123;index&#125;?pretty&quot;</span><br><span class="line">  else</span><br><span class="line">    echo &quot;&quot;</span><br><span class="line">  fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure></div><p>然后使用crontab每天定时执行一次这个脚本。</p><h2 id="集群分片设置"><a href="#集群分片设置" class="headerlink" title="集群分片设置"></a>集群分片设置</h2><p>ES一旦创建好索引后，就无法调整分片的设置，而在ES中，一个分片实际上对应一个lucene 索引，而lucene索引的读写会占用很多的系统资源，因此，分片数不能设置过大；所以，在创建索引时，合理配置分片数是非常重要的。一般来说，我们遵循一些原则：</p><ol><li>控制每个分片占用的硬盘容量不超过ES的最大JVM的堆空间设置（一般设置不超过32G，参加上文的JVM设置原则），因此，如果索引的总容量在500G左右，那分片大小在16个左右即可；当然，最好同时考虑原则2。</li><li>考虑一下node数量，一般一个节点有时候就是一台物理机，如果分片数过多，大大超过了节点数，很可能会导致一个节点上存在多个分片，一旦该节点故障，即使保持了1个以上的副本，同样有可能会导致数据丢失，集群无法恢复。所以， 一般都设置分片数不超过节点数的3倍。</li></ol><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>1.修改index_buffer_size 的设置，可以设置成百分数，也可设置成具体的大小，大小可根据集群的规模做不同的设置测试。</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">indices.memory.index_buffer_size：10%（默认）</span><br><span class="line">indices.memory.min_index_buffer_size： 48mb（默认）</span><br><span class="line">indices.memory.max_index_buffer_size</span><br></pre></td></tr></table></figure></div><ol><li>_id字段的使用，应尽可能避免自定义_id, 以避免针对ID的版本管理；建议使用ES的默认ID生成策略或使用数字类型ID做为主键。</li><li>_all字段及_source字段的使用，应该注意场景和需要，_all字段包含了所有的索引字段，方便做全文检索，如果无此需求，可以禁用；_source存储了原始的document内容，如果没有获取原始文档数据的需求，可通过设置includes、excludes 属性来定义放入_source的字段。</li><li>合理的配置使用index属性，analyzed 和not_analyzed，根据业务需求来控制字段是否分词或不分词。只有 groupby需求的字段，配置时就设置成not_analyzed, 以提高查询或聚类的效率。</li></ol><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><ul><li>查询优化，调整filter过滤顺序</li></ul><p>如果把过滤效果不明显的条件放在了前面，导致查询出大量不需要的数据，导致查询变慢。 把过滤效果明显的条件提前，按照过滤效果把过滤条件排序</p><ul><li>索引时间精度优化</li></ul><p>研究Filter的工作原理可以看出，它每次工作都是遍历整个索引的，所以时间粒度越大，对比越快，搜索时间越短，在不影响功能的情况下，时间精度越低越好，有时甚至牺牲一点精度也值得，当然最好的情况是根本不作时间限制。 es重新刷索引，增加冗余的时间字段，精确到天。带有时间范围的查询使用该字段进行查询</p><ul><li>查询Fetch Source优化</li></ul><p>业务查询语句获取的数据集比较大，并且从source中获取了非必须的字段，导致查询较慢。 举例：只需要从es中查询id这一个字段，却把所有字段查询了出来</p><ul><li>预索引数据</li></ul><p>利用索引查询数据是最优的方式。例如，如果所有的文档都有 price 字段，并且大多数查询都在一个固定的范围列表中运行范围聚合，那么可以通过将 index 预索引到 index 和使用 terms 聚合来更快地实现聚合。</p><p>例如，像下面这样：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT index/type/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;designation&quot;: &quot;spoon&quot;,</span><br><span class="line">  &quot;price&quot;: 13</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>像这样的查询：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;price_ranges&quot;: &#123;</span><br><span class="line">      &quot;range&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;,</span><br><span class="line">        &quot;ranges&quot;: [</span><br><span class="line">          &#123; &quot;to&quot;: 10 &#125;,</span><br><span class="line">          &#123; &quot;from&quot;: 10, &quot;to&quot;: 100 &#125;,</span><br><span class="line">          &#123; &quot;from&quot;: 100 &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>文档在索引的时候要使用 price_range ，应该被映射为关键词：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PUT index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;price_range&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT index/type/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;designation&quot;: &quot;spoon&quot;,</span><br><span class="line">  &quot;price&quot;: 13,</span><br><span class="line">  &quot;price_range&quot;: &quot;10-100&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后这个请求就直接聚合新字段，而不是在 price 字段运行范围查询：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;price_ranges&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price_range&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，ElasticSearch的优化，优化可以从以下方面的考虑：</p><ul><li>硬件的优化：机器分配，机器配置，机器内存，机器CPU，机器网络，机器磁盘性能</li><li>操作系统设置优化：文件句柄优化、swap关闭</li><li>ElasticSearch合理分配节点，合理分配参加竞选Master的节点</li><li>ElasticSearch的存储的优化，副本数量、索引数量、分片数量</li><li>ElasticSearch的使用优化，索引的优化，查询的优化</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Elasticsearch常常作为日志存储和分析的工具，在企业级应用中常常使用。Elasticsearch提供强大的搜索、分析功能，已经是后端技术栈不可缺少的一部分。 在维护ElastciSearch集群的时候，对Elasticsearch进行了一些调优和分析，现整理成文，</summary>
      
    
    
    
    <category term="搜索引擎" scheme="http://example.com/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 JDK8 能提升开发效率的方式</title>
    <link href="http://example.com/2019/06/30/java/jdk8-new-feature/"/>
    <id>http://example.com/2019/06/30/java/jdk8-new-feature/</id>
    <published>2019-06-30T10:01:54.000Z</published>
    <updated>2023-11-17T11:37:37.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 自1.0 版本发布以来，java8 可以说是变化最大的一次。基于函数式编程思想，它本身并没有删除原有的东西，所以就算升级了 java8，好多人的编码方式还是按照以前的来，并没有使用到 java8 的新功能，所以也没意识到 java8 带给我们开发人员的便利。</p><p>也有一些人，在了解了 java8 的新特性后，认为其改变了一直以来的编码习惯，对其产生了抵触心理，并未在项目中使用。</p><p>但是 java8 提供的新特性还是很强大的，通过这些新特性，可以帮助我们写出更简洁，更清晰的代码</p><h1 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h1><h2 id="接口的-默认方法和静态方法"><a href="#接口的-默认方法和静态方法" class="headerlink" title="接口的 默认方法和静态方法"></a>接口的 默认方法和静态方法</h2><p>Java8 允许在接口中定义默认方法和静态方法，对于这两种方法，可以直接在接口中实现，无需在实现类中实现。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">  <span class="comment">// 抽象方法 </span></span><br><span class="line">  String <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterface method invoke...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyInterface staticMethod invoke...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>扩展方法，在方法前需要用<code>default</code>关键字修饰，不能通过接口调用，必须通过接口实现类的实例对象进行方法调用</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyInterfaceImpl</span> <span class="variable">myInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterfaceImpl</span>();</span><br><span class="line">myInterface.defaultMethod();</span><br></pre></td></tr></table></figure></div><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>在接口中，用 static 关键字修饰的方法，可以通过接口直接调用</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyInterface.staticMethod();</span><br></pre></td></tr></table></figure></div><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>接口的实现类，对于普通的抽象方法，必须要重写，这个不用多说;</p><p>对于默认方法，可以选择重写，也可以不重写;</p><p>接口的静态方法无法被重写；</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>一个接口 A 有一个默认方法 method，一个父类B也有个方法 method，如果有个子类既实现了接口 A，又继承了父类 B，那么在 A 执行 method 时，调用的是接口的呢还是 父类的呢？</p><p>答案是： 父类的（类优先原则）</p><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>Lambda表达式是Java8中非常重要的一个新特性，其基于函数式编程的思想，支持将代码作为方法参数进行使 用。可以把Lambda表达式理解为通过一种更加简洁的方式表示可传递的匿名函数。</p><p>它本身没有名称，而且不像方法那样属于某一个类，但是可以有参数列表、代码体、返回值。使用了Lambda表达 式之后就不需要再去编写匿名类了。</p><h3 id="Lambda-基础格式"><a href="#Lambda-基础格式" class="headerlink" title="Lambda 基础格式"></a>Lambda 基础格式</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表) ‐&gt; &#123; 方法体 &#125;</span><br></pre></td></tr></table></figure></div><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>在Java8中为了让现在有的函数能够更加友好的使用Lambda表达式，因此引入了函数式接口这个概念。其是一个 仅有一个抽象方法的普通接口。如果声明多个抽象方法则会报错。但是默认方法和静态方法在此接口中可以定义多 个。</p><p>要想自定义一个函数式接口的话，需要在接口上添加 <code>@FunctionalInterface </code></p><h3 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h3><p>在Java8的类库设计中，已经引入了几个函数式接口：Predicate、Consumer、Function、Supplier</p><blockquote><p>Predicate 用于判断操作，抽象方法 test</p><p>Consumer 用于获取数据后对数据进行某些操作，抽象方法 accept</p><p>Function 用于类型转换，抽象方法 apply</p><p>Supplier 生成数据，抽象方法 get</p></blockquote><h2 id="类型检查-推断"><a href="#类型检查-推断" class="headerlink" title="类型检查&amp;推断"></a>类型检查&amp;推断</h2><p>Lambda表达式中对于数据类型是可以不用声明的，lambda直接就能进行 正确的运算，那么对于这一点，Lambda表达式内部又是如何来进行实现的呢？</p><p>其实对于Lambda表达式的类型推断，它是对Java之前版本中的目标类型推断进行的再次扩展。</p><p>如：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></div><p>那么在Java8中对于这种使用方式又进一步扩展，可以省略Lambda表达式中的所有参数类型。在编译时根据 Lambda表达式的上下文信息推断出参数的正确类型。这就是所谓的类型推断。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span> x,<span class="type">int</span> y) ‐&gt;&#123; </span><br><span class="line">  System.out.println(x); </span><br><span class="line">  System.out.println(x); </span><br><span class="line">  <span class="keyword">return</span> x+y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(x,y) ‐&gt;&#123; </span><br><span class="line">  System.out.println(x); </span><br><span class="line">  System.out.println(x); </span><br><span class="line">  <span class="keyword">return</span> x+y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p><code>类名或实例名::方法名</code></p><h2 id="Stream流使用"><a href="#Stream流使用" class="headerlink" title="Stream流使用"></a>Stream流使用</h2><p>可以参考：<a class="link"   href="https://mp.weixin.qq.com/s/WmG781nHGZdvcOYbHM2gIw" >https://mp.weixin.qq.com/s/WmG781nHGZdvcOYbHM2gIw <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="数据并行化"><a href="#数据并行化" class="headerlink" title="数据并行化"></a>数据并行化</h2><p>stream() 串行流</p><p>parallelStream() 并行流</p><p>当处理一个流时，如果处理的逻辑不要求先后顺序的话，可以使用并行流</p><h3 id="并行流原理"><a href="#并行流原理" class="headerlink" title="并行流原理"></a>并行流原理</h3><p>对于并行流，其在底层实现中，是沿用了Java7提供的fork&#x2F;join分解合并框架进行实现。fork根据 cpu 核数进行数据分块，join 对各个fork 进行合并</p><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><p>对于并行流，不一定就比串行快，影响并行速度的主要是五个因素：</p><ol><li><p>数据大小，因为在并行内部实现中涉及到了fork&#x2F;join操作，它 本身就存在性能上的开销。因此只有当数据量很大，使用并行处理才有意义。</p></li><li><p>源数据结构，fork时会对源数据进行分割，数据源的特性直接影响了fork的性能。</p><blockquote><p>ArrayList、数组或IntStream.range，可分解性最佳，因为他们都支持随机读取，因此可以被任意分割。</p><p>HashSet、TreeSet，可分解性一般，其虽然可被分解，但因为其内部数据结构，很难被平均分解。</p><p>LinkedList、Streams.iterate、BufferedReader.lines，可分解性极差，不好确定在哪里进行 分割。</p></blockquote></li><li><p>装箱拆箱,  尽量使用基本数据类型，避免装箱拆箱。</p></li><li><p>CPU核数 , fork的产生数量是与可用CPU核数相关，可用的核数越多，获取的性能提升就会越大。</p></li><li><p>单元处理开销，花在流中每个元素的时间越长，并行操作带来的性能提升就会越明显。</p></li></ol><h2 id="异步编程-CompleTableFuture"><a href="#异步编程-CompleTableFuture" class="headerlink" title="异步编程 CompleTableFuture"></a>异步编程 CompleTableFuture</h2><p>在互联网开发中，经常要求设计出性能更加优异的系统，就上上面提到的数据并行化，就上充分利用多核处理器结合并行操作来让代码执行效率会更加优异。</p><p>比如在微博里里，点击某条微博详情，需要查询该条微博的点赞数、转发数和评论数，假设点赞、转发、评论是分属三个不同系统中的业务，那么就需要在聚合层调用三个基础服务获取这三个数据，但其实在这个业务中，查询点赞数、转发数、评论数这三者是没有先后逻辑关系的，各自完成自己的事情，那么就会考虑开启多个线程，让他们能够在各自的子 线程中完成自己的任务。</p><p>在开发中对于松耦合服务，需要让他们尽量的并行执行，避免阻塞出现，从而最大化程序的吞吐量。</p><h3 id="同步API"><a href="#同步API" class="headerlink" title="同步API"></a>同步API</h3><p>同步API就是传统的方法调用，以串行的形式实现。比方当调用多个方法时，第一个方法执行时，其他方法会产生 等待，当第一个方法执行完之后，取得返回结果后，后续的方法在继续逐一执行。对于这种调用方式，一般称之为阻塞式调用。</p><h3 id="异步API"><a href="#异步API" class="headerlink" title="异步API"></a>异步API</h3><p>异步API采用并行的形式完成方法执行，当第一个方法在执行并且未执行完时，开始另外的线程去执行其他的方法，这种方式称之为 非阻塞式调用。值得注意的是，每一个任务线程会将自己的结果返回给调用方， 方式有两种，要么是回调，要么通过调用方再次执行一个“等待-&gt;结束”的方法。</p><h2 id="StampedLock锁"><a href="#StampedLock锁" class="headerlink" title="StampedLock锁"></a>StampedLock锁</h2><p>StampedLock类是在JDK8引入的一把新锁，其是对原有ReentrantReadWriteLock读写锁的增强，增加了一个乐 观读模式，内部提供了相关API不仅优化了读锁、写锁的访问，也可以让读锁与写锁间可以互相转换，从而更细粒 度的控制并发。</p><p>Oracle 官方示例：<a class="link"   href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/StampedLock.html" >https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/StampedLock.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java 自1.0 版本发布以来，java8 可以说是变化最大的一次。基于函数式编程思想，它本身并没有删除原有的东西，所以就算升级了 jav</summary>
      
    
    
    
    <category term="Java技术" scheme="http://example.com/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="jdk" scheme="http://example.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构中常用的实现幂等性的方式总结</title>
    <link href="http://example.com/2019/06/04/java/idempotence/"/>
    <id>http://example.com/2019/06/04/java/idempotence/</id>
    <published>2019-06-04T11:44:48.000Z</published>
    <updated>2023-11-17T11:37:37.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="幂等性的定义"><a href="#幂等性的定义" class="headerlink" title="幂等性的定义"></a>幂等性的定义</h2><p>幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多点点击或多次请求产生副作用。</p><p>举例：用户购买商品支付，支付扣款成功，但是返回结果时网络异常，这时候钱其实已经扣了，用户以为支付失败了，再次点击支付，会进行第二次扣款，返回结果成功，用户查询产生了两条扣款记录，多扣钱了，这就是非幂等。</p><h2 id="幂等性的范围"><a href="#幂等性的范围" class="headerlink" title="幂等性的范围"></a>幂等性的范围</h2><p>在数据访问层，要求幂等性的往往是对数据写入时。</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><ul><li>需要做幂等性</li></ul><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><ul><li>重复删除操作天然是幂等的</li></ul><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><ul><li>直接更新某个值的，不需要作幂等</li><li>累加等计算操作的更新，需要作幂等</li></ul><h2 id="幂等性解决方案"><a href="#幂等性解决方案" class="headerlink" title="幂等性解决方案"></a>幂等性解决方案</h2><p>解决幂等性没有最优的，只有最合适的，根据自己的业务自己选型</p><h3 id="insert-幂等"><a href="#insert-幂等" class="headerlink" title="insert 幂等"></a>insert 幂等</h3><ol><li><h4 id="数据库增加唯一字段"><a href="#数据库增加唯一字段" class="headerlink" title="数据库增加唯一字段"></a>数据库增加唯一字段</h4><ul><li>优点：实现方式简单方便</li><li>缺点：影响数据库性能，尤其是在数据频繁更新的场景，唯一索引比普通索引在写时开销还要大很多，而且还需要专门对 “duplicate key” 异常处理。</li></ul></li><li><h4 id="细粒度分布式锁-select-insert"><a href="#细粒度分布式锁-select-insert" class="headerlink" title="细粒度分布式锁 + select +insert"></a>细粒度分布式锁 + select +insert</h4><p>在操作时，先加一个细粒度的分布式锁，再去查询数据是否存在，不存在再 insert</p><ul><li>优点：性能影响较少，使用的是细粒度锁，所以只有重复提交记录时才会阻塞</li><li>缺点：写操作会增加一次select开销，实现难度相对较大因为需要分布式细粒度锁，而且这个锁的时间需要根据业务场景去确定。</li></ul></li></ol><h3 id="update-幂等"><a href="#update-幂等" class="headerlink" title="update 幂等"></a>update 幂等</h3><ol><li><h4 id="update-常用的手段是-版本号控制"><a href="#update-常用的手段是-版本号控制" class="headerlink" title="update 常用的手段是 版本号控制"></a>update 常用的手段是 版本号控制</h4></li></ol><ul><li><p>表里添加  version 字段</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table test_table add version int default 0;</span><br></pre></td></tr></table></figure></div></li><li><p>然后更新的时候通过这个version来判断是否为过期无效操作，这是乐观锁的一种思路</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from tablename where condition=#&#123;condition&#125;  -- 查询出 version</span><br><span class="line">update test_table set age=age+1, version=version+1 where version=xx</span><br></pre></td></tr></table></figure></div><p>为了避免失败，一般还要有重试机制</p></li></ul><ol start="2"><li><h4 id="有限状态机幂等"><a href="#有限状态机幂等" class="headerlink" title="有限状态机幂等"></a>有限状态机幂等</h4><p>业务单据上有个状态，状态在不同的情况下会发生变更，一般情况下是有限状态机，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p><p>比如订单新建状态为 0，付款失败为 9，付款成功为 10，在做状态机更新时可以这样：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update `order` set status=#&#123;status&#125; where id=#&#123;id&#125; and status&lt;#&#123;status&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>select for update 不推荐用。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;幂等性的定义&quot;&gt;&lt;a href=&quot;#幂等性的定义&quot; class=&quot;headerlink&quot; title=&quot;幂等性的定义&quot;&gt;&lt;/a&gt;幂等性的定义&lt;/h2&gt;&lt;p&gt;幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多点点击或多次请求产生副作用。&lt;</summary>
      
    
    
    
    <category term="项目实战" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="架构" scheme="http://example.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>过期订单自动取消的几种实现方式</title>
    <link href="http://example.com/2019/05/01/mq/rabbitmq/cancel-expired-order/"/>
    <id>http://example.com/2019/05/01/mq/rabbitmq/cancel-expired-order/</id>
    <published>2019-05-01T05:20:16.000Z</published>
    <updated>2023-11-17T11:37:37.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在电商系统中，经常会遇到这样的场景：当订单未支付超时，需要自动取消订单，否则会一直占用库存等资源。</p><p>那么实现订单未支付超时，自动取消的方式有哪些呢？这里列举些我了解的几种方式。</p><h3 id="扫表实现"><a href="#扫表实现" class="headerlink" title="扫表实现"></a>扫表实现</h3><blockquote><p> 原理： 通过定时任务轮询扫描订单表，超时的批量修改状态</p><p>优点： 实现非常简单 </p><p>缺点:大量数据集，对服务器内存消耗大。 数据库频繁查询，订单量大的情况下，IO是瓶颈。 存在延迟，间隔短则耗资源，间隔长则时效性差，两者是一对矛盾。 不易控制，随着定时业务的增多和细化，每个业务都要对订单重复扫描，引发查询浪费</p></blockquote><h3 id="java-延迟队列实现"><a href="#java-延迟队列实现" class="headerlink" title="java 延迟队列实现"></a>java 延迟队列实现</h3><blockquote><p> 原理： 通过DelayQueue，每下一单，放入一个订单元素并实现getDelay()方法，方法返回该元素距离失效还剩余的时 间，当&lt;&#x3D;0时元素就失效，就可以从队列中获取到。启用线程池对数据监听，一旦捕获失效订单，取出之后，调用 取消逻辑进行处理。</p><p>优点:基于jvm内存，效率高，任务触发时间延迟低。</p><p>缺点:存在jvm内存中，服务器重启后，数据全部丢失。 依赖代码硬编码，集群扩展麻烦 依赖jvm内存，如果订单量过大，无界队列内容扩充，容易出现OOM 需要代码实现，多线程处理业务，复杂度较高 多线程处理时，数据频繁触发等待和唤醒，多了无谓的竞争</p></blockquote><h3 id="消息队列实现"><a href="#消息队列实现" class="headerlink" title="消息队列实现"></a>消息队列实现</h3><blockquote><p> 原理：设置两个队列，每下一单放一条进延迟队列，设定过期时间。消息一旦过期，获取并放入工作队列，由consumer 获取，唤起超时处理逻辑。</p><p>**如果采用的是RabbitMQ，其本身没有直接支持延迟队列功能，可以针对Queue和Message设置 x-message-ttl， 用消息的生存时间，和死信队列来实现，具体有两种手段， A: 通过队列属性设置，队列中所有消息都有相同的过 期时间，粗粒度，编码简单 B: 对消息进行单独设置，每条消息TTL可以不同，细粒度，但编码稍微复杂。 **</p><p>优点：可以随时在队列移除，实现实时取消订单，及时恢复订单占用的资源（如商品）</p><p>消息存储在mq中，不占用应用服务器资源</p><p>异步化处理，一旦处理能力不足，consumer集群可以很方便的扩容</p><p>缺点：可能会导致消息大量堆积 mq服务器一旦故障重启后，持久化的队列过期时间会被重新计算，造成精度不足 死信消息可能会导致监控系统频繁预警</p></blockquote><h3 id="redis实现"><a href="#redis实现" class="headerlink" title="redis实现"></a>redis实现</h3><blockquote><p>原理:利用redis的notify-keyspace-events，该选项默认为空，改为Ex开启过期事件，配置消息监听。每下一单在redis中 放置一个key（如订单id），并设置过期时间。</p><p>优点:消息都存储在Redis中，不占用应用内存。 外部redis存储，应用down机不会丢失数据。 做集群扩展相当方便 依赖redis超时，时间准确度高</p><p>缺点:订单量大时，每一单都要存储redis内存，需要大量redis服务器资源</p></blockquote><h3 id="被动取消"><a href="#被动取消" class="headerlink" title="被动取消"></a>被动取消</h3><blockquote><p>原理：在每次用户查询订单的时候，判断订单时间，超时则同时完成订单取消业务。</p><p>优点：实现极其简单 不会有额外的性能付出 不依赖任何外部中间件，只是应用逻辑的处理</p><p>缺点：延迟度不可控，如果用户一直没触发查询，则订单一直挂着，既不支付也未取消，库存也就被占着</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在电商系统中，经常会遇到这样的场景：当订单未支付超时，需要自动取消订单，否则会一直占用库存等资源。&lt;/p&gt;
&lt;p&gt;那么实现订单未支付超时，自</summary>
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="rabbitmq" scheme="http://example.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 配置加载优先级顺序</title>
    <link href="http://example.com/2019/04/15/springboot/spring-boot-config-load-order/"/>
    <id>http://example.com/2019/04/15/springboot/spring-boot-config-load-order/</id>
    <published>2019-04-15T09:48:32.000Z</published>
    <updated>2023-11-17T11:37:36.915Z</updated>
    
    <content type="html"><![CDATA[<p>根据官网和极客时间丁雪丰老师 Spring 专课，总结归纳下 SpringBoot 加载配置的顺序，以便以后遇到问题了好排查。</p><p>外化配置优先级顺序：</p><ol><li>开启 DevTools 时，~&#x2F;.spring-boot-devtools.properties；</li><li>测试类上的 @TestPropertySource 注解；</li><li>@SpringBootTest#properties 注解；</li><li>命令行参数，如 –server.port&#x3D;8888;</li><li>SPRING_APPLICATION_JSON 属性;</li><li>ServletConfig 初始化参数；</li><li>ServletContext 初始化参数；</li><li>Java:comp&#x2F;env 中的JNDI 属性；</li><li>System.getProperties()属性；</li><li>操作系统环境变量；</li><li>random.*  RrandomValuePropertySource，如 my.age&#x3D;${random.int}</li><li>jar 包外部的 application-(profile).properties 或（yml）</li><li>jar 包内部的 application-(profile).properties 或（yml）</li><li>jar 包外部的 application.properties 或（yml）</li><li>jar 包内部的 application.properties 或（yml）</li><li>@Configuration 类上的 @PropertySpurce；</li><li>SpringApplication.setDefaultProperties() 设置默认属性。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;根据官网和极客时间丁雪丰老师 Spring 专课，总结归纳下 SpringBoot 加载配置的顺序，以便以后遇到问题了好排查。&lt;/p&gt;
&lt;p&gt;外化配置优先级顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开启 DevTools 时，~&amp;#x2F;.spring-boot-devtools</summary>
      
    
    
    
    <category term="Java框架" scheme="http://example.com/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="springboot" scheme="http://example.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 7.x 入门与实践</title>
    <link href="http://example.com/2019/04/10/elasticsearch/introduction-practice/"/>
    <id>http://example.com/2019/04/10/elasticsearch/introduction-practice/</id>
    <published>2019-04-10T10:01:54.000Z</published>
    <updated>2023-11-17T11:37:37.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们建立一个网站或者应用程序，经常用到搜索功能，我们自己实现复杂的搜索且性能强大、高可用、运行速度快是非常困难的，Elasticsearch 很好地帮助我们解决了这个问题。</p><p>百度百科：<a class="link"   href="https://baike.baidu.com/item/elasticsearch/3411206?fr=aladdin" >https://baike.baidu.com/item/elasticsearch/3411206?fr=aladdin <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>官网地址：<a class="link"   href="https://www.elastic.co/cn/products/elasticsearch" >https://www.elastic.co/cn/products/elasticsearch <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>Github：<a class="link"   href="https://github.com/elastic/elasticsearch" >https://github.com/elastic/elasticsearch <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="ES-优点"><a href="#ES-优点" class="headerlink" title="ES 优点"></a>ES 优点</h2><ol><li>可以实时地去索引、搜索数据。</li><li>扩展性好，可部署上百台服务器做集群，处理 PB 级数据。</li></ol><h1 id="ES-原理、应用"><a href="#ES-原理、应用" class="headerlink" title="ES 原理、应用"></a>ES 原理、应用</h1><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://www.zhengyk.cn/images/es-structure.jpg"                                     ></p><p>ES 的索引是<a href="%5Bhttps://baike.baidu.com/item/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/11001569%5D(https://baike.baidu.com/item/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/11001569)">倒排索引</a>表，ES 将要被搜索的数据根据指定的分词器进行分词，这些数据在 ES 中以文档存储，并将这些分词与文档进行关联。</p><h2 id="Restful"><a href="#Restful" class="headerlink" title="Restful"></a>Restful</h2><p>ES 通过提供 restful api 供客户端使用</p><h2 id="ES-文件目录结构"><a href="#ES-文件目录结构" class="headerlink" title="ES 文件目录结构"></a>ES 文件目录结构</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://www.zhengyk.cn/images/es-file-dir.jpg"                                     ></p><blockquote><p>bin:：可执行文件</p><p>config：配置文件</p><blockquote><p>jvm.options：配置 es 的 jvm 参数，一般将 xms 和 xmn设置为</p><p>log4j2.properties：es 使用 log4j2 打印日志</p><p>elasticsearch.yml：es 核心配置文件</p></blockquote><p>data：数据</p><p>logs：日志</p><p>modules：es模块目录</p><p>plugins：es 插件比如 ik 分词器</p></blockquote><h2 id="elasticsearch-yml-常用配置"><a href="#elasticsearch-yml-常用配置" class="headerlink" title="elasticsearch.yml 常用配置"></a>elasticsearch.yml 常用配置</h2><blockquote><p>cluster.name: es 集群的名称 默认是 elasticsearch ，建议修改为与项目相关的名称。</p><p>node.name: 此 es 节点名称，通常一个 es 应用就是一个节点，建议指定。</p><p>node.master: 指定该节点是否有资格被选举成为master结点，默认是true，如果原来的master宕机会重新选举新</p><p>的master。 </p><p>node.data: 指定该节点是否存储索引数据，默认为true。</p><p>path.data: 索引数据的存储路径。</p><p>path.logs: 日志文件的存储路径。</p><p>bootstrap.memory_lock: true 设置为true可以锁住ES使用的内存，避免内存与swap分区交换数据。</p><p>network.host: 设置绑定主机的ip地址，设置为0.0.0.0表示绑定任何ip，允许外网访问，生产环境建议设置为具体 的ip。 </p><p>http.port: 9200 设置对外服务的http端口，默认为9200。</p><p>transport.tcp.port: 9300 集群结点之间通信端口。</p><p>http.cors.enabled: true<br>http.cors.allow-origin: “*”  允许跨域。</p><p>discovery.zen.ping.timeout: 3s 设置ES自动发现节点连接超时的时间，默认为3秒，如果网络延迟高可设置大些。</p><p>discovery.zen.minimum_master_nodes：为了防止数据丢失，这个 配置在 7.x 版本之前至关重要， 以便每个候选主节点知道为了形成集群而必须可见的最少数量的候选主节点。没有这种设置，遇到网络故障的群集有可能将群集分成两个独立的群集（脑裂）， 这将导致数据丢失。为了避免脑裂，候选主节点的数量应该设置为：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master_eligible_nodes / 2) + 1</span><br></pre></td></tr></table></figure></div><p>换句话说，如果现在有3个节点，最小候选主节点数应该是（3&#x2F;2)+1&#x3D;2。</p><p>注意：在 Elasticsearch 7.x 中，重新设计并重建了集群协调子系统：移除了 minimum_master_nodes 设置，让 Elasticsearch 自己选择可以形成法定数量的节点。</p><ul><li>好处1：用户无需设置最小主节点个数了，集群层面给解决了。</li><li>好处2：避免用户配置错误导致出现脑裂问题。</li><li>好处3：选主更快了。</li></ul><p>虽然在 7.x 版本中不用配置此参数，但也需要了解一下其原理。</p></blockquote><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><p>ES 部署到 Linux 服务器上，一般需要将每个进程最多允许打开的文件数设置的大一些。</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n // 查看当前最大文件打开数</span><br></pre></td></tr></table></figure></div><p>&#x2F;etc&#x2F;security&#x2F;limits.conf 文件中加入 </p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch ‐ nofile 65535</span><br></pre></td></tr></table></figure></div><p>表示 为 elasticsearch 用户设置最大文件打开数为 65535</p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="Ik-分词器"><a href="#Ik-分词器" class="headerlink" title="Ik 分词器"></a>Ik 分词器</h2><p>ES 中我们经常使用的中文分词器是 ik 分词器</p><p>Github: <a class="link"   href="https://github.com/medcl/elasticsearch-analysis-ik" >https://github.com/medcl/elasticsearch-analysis-ik <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>下载与 es 版本对应的 ik分词器，将其解压后放置 es 的 plugins目录下，并命名为 ik</p><p>ik分词器还支持自定义词库。</p><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>ES 索引(index)是个逻辑概念，包括了分词列表和文档，相当于 mysql 中的表</p><p>ES 的文档可以理解为 mysql 表中的每一行数据</p><p>ES 的字段可以理解为 mysql 表中的每列字段</p><p>示例：使用 head 插件创建索引</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://www.zhengyk.cn/images/create-es-index.jpg"                                     ></p><p>单机情况下，数据分片为 1，副本数为 0 即可。</p><h2 id="创建映射"><a href="#创建映射" class="headerlink" title="创建映射"></a>创建映射</h2><p>一个索引中的文档包括多个字段，创建映射就是为索引创建字段的过程，</p><p>注意：ES 在6.0之前版本中 type 的概念，但是之后不使用了，ES 官方计划将于 9.0版本中彻底删除 type。</p><p>head 插件中发送 post 请求创建 mapping</p><p><img src="https://www.zhengyk.cn/images/create-es-mapping.jpg" alt="https://www.zhengyk.cn/images/create-es-mapping.jpg"></p><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;text&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;number&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;keyword&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><h2 id="查看映射"><a href="#查看映射" class="headerlink" title="查看映射"></a>查看映射</h2><p>发送 get 请求即可</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://www.zhengyk.cn/images/get-es-mapping.jpg"                                     ></p><h2 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h2><p>映射创建成后，可以添加新字段，已有的字段不允许更新，如果非要更新则需要重新创建索引、映射。</p><h2 id="删除映射"><a href="#删除映射" class="headerlink" title="删除映射"></a>删除映射</h2><p>通过删除索引来删除映射</p><h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><h3 id="文本类型-text-和-keyword"><a href="#文本类型-text-和-keyword" class="headerlink" title="文本类型 text 和 keyword"></a>文本类型 text 和 keyword</h3><blockquote><p>text: 内容会被分词，不能用于排序 </p><p>​analyzer：指定分词器 如：ik_max_word</p><p>​    search_analyzer：单独指定搜索时的分词器</p><p>​    ik中文分词最佳实践：索引时使用ik_max_word将搜索内容进行细粒度分词，搜索时使用ik_smart提高搜索精确性。</p><pre><code><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span><span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span><span class="string">&quot;ik_smart&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div></code></pre><p>keyword: 内容不会被分词</p></blockquote><p>text 和 keyword 都可以通过index属性指定是否索引：</p><p>默认为index&#x3D;true，即要进行索引，只有进行索引才可以从索引库搜索到。</p><p>但是也有一些内容不需要索引，比如:商品图片地址只被用来展示图片，不进行搜索图片，此时可以将index设置 为false。</p><p>store:</p><p>是否在source之外存储，默认 false，每个文档索引后会在 ES中保存一份原始文档，存放在”_source”中，一般情况下不需要设置 store为 true，因为在 _source 中已经有一份原始文档了。</p><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>数字类型有如下分类:</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>byte</td><td>有符号的8位整数, 范围: [-128 ~ 127]</td></tr><tr><td>short</td><td>有符号的16位整数, 范围: [-32768 ~ 32767]</td></tr><tr><td>integer</td><td>有符号的32位整数, 范围: [$-2^{31}$ ~ $2^{31}$-1]</td></tr><tr><td>long</td><td>有符号的32位整数, 范围: [$-2^{63}$ ~ $2^{63}$-1]</td></tr><tr><td>float</td><td>32位单精度浮点数</td></tr><tr><td>double</td><td>64位双精度浮点数</td></tr><tr><td>half_float</td><td>16位半精度IEEE 754浮点类型</td></tr><tr><td>scaled_float</td><td>缩放类型的的浮点数, 比如price字段只需精确到分, 57.34缩放因子为100, 存储结果为5734</td></tr></tbody></table><p>使用注意事项:</p><p><em><strong>尽可能选择范围小的数据类型, 字段的长度越短, 索引和搜索的效率越高;</strong></em></p><h3 id="日期类型-date"><a href="#日期类型-date" class="headerlink" title="日期类型 date"></a>日期类型 date</h3><p>日期类型不用设置分词器，通常日期类型的字段用于排序。</p><p>可以用 format 来指定日期格式：</p><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;date&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span><span class="string">&quot;yyyy‐MM‐dd HH:mm:ss||yyyy‐MM‐dd||epoch_millis&quot;</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><p>表示该日期支持 年月日时分秒 、年月日和时间戳三种格式。</p><h2 id="创建文档"><a href="#创建文档" class="headerlink" title="创建文档"></a>创建文档</h2><p>使用 put 或 post 请求为索引创建文档，如果不指定 id，es 会默认创建</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="ES-客户端"><a href="#ES-客户端" class="headerlink" title="ES 客户端"></a>ES 客户端</h2><ol><li><p>TransportClient：ES提供的传统客户端，官方计划8.0版本删除此客户端。</p></li><li><p>RestClient：</p><p>RestClient是官方推荐使用的，它包括两种:Java Low Level REST Client和 Java High Level REST Client。</p><p>ES在6.0之后提供 Java High Level REST Client， 两种客户端官方更推荐使用 Java High Level REST Client，不过当 前它还处于完善中，有些功能还没有，在我们的项目中使用足够了。</p></li></ol><p>注：spring 虽然已经集成了es spring-data-elasticsearch，并提供了一些常用的操作 ES 的 api，但考虑到我们搜索业务的复杂性，最终选用更灵活，更适合我们的 es 官网提供的客户端。</p><h3 id="maven-依赖"><a href="#maven-依赖" class="headerlink" title="maven 依赖"></a>maven 依赖</h3><p>以 7.3.2 版本为例：</p><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>用的是 springboot 构建的项目，yml 配置文件中添加</p><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">elasticsearch:</span></span><br><span class="line">  <span class="attr">hostList:</span> <span class="number">192.168</span><span class="number">.220</span><span class="number">.252</span><span class="string">:9200</span> <span class="comment">#多个节点之间用逗号分隔</span></span><br></pre></td></tr></table></figure></div><p>配置类：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticsearchConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.hostList&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String hostList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">restHighLevelClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 解析hostList配置信息</span></span><br><span class="line">        HttpHost[] httpHostArray = getHttpHosts();</span><br><span class="line">        <span class="comment">// 创建RestHighLevelClient客户端</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(httpHostArray));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpHost[] getHttpHosts() &#123;</span><br><span class="line">        String[] split = hostList.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建HttpHost数组，其中存放es主机和端口的配置信息</span></span><br><span class="line">        HttpHost[] httpHostArray = <span class="keyword">new</span> <span class="title class_">HttpHost</span>[split.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; split.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> split[i];</span><br><span class="line">            httpHostArray[i] = <span class="keyword">new</span> <span class="title class_">HttpHost</span>(item.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>], Integer.parseInt(item.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]), <span class="string">&quot;http&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> httpHostArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><p>创建 book 索引和对应 mapping：</p><p>post  <a class="link"   href="http://localhost:9200/book/_mapping" >http://localhost:9200/book/_mapping <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span><span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span><span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span><span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span><span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pic&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;serialNumber&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;keyword&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;date&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span><span class="string">&quot;yyyy‐MM‐dd HH:mm:ss||yyyy‐MM‐dd||epoch_millis&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;double&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div><p>向 book 索引插入文档：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//准备json数据</span></span><br><span class="line">Map&lt;String, Object&gt; jsonMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">jsonMap.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;深入理解Java虚拟机:JVM高级特性与最佳实践&quot;</span>);</span><br><span class="line">jsonMap.put(<span class="string">&quot;desc&quot;</span>, <span class="string">&quot;作为一位Java程序员，你是否也曾经想深入理解Java虚拟机，但是却被它的复杂和深奥拒之门外？没关系，本书极尽化繁为简之妙，能带领你在轻松中领略Java虚拟机的奥秘。本书是近年来国内出版的唯一一本与Java虚拟机相关的专著，也是唯一一本同时从核心理论和实际运用这两个角度去探讨Java虚拟机的著作，不仅理论分析得透彻，而且书中包含的典型案例和最佳实践也极具现实指导意义。&quot;</span>);</span><br><span class="line">jsonMap.put(<span class="string">&quot;number&quot;</span>, <span class="string">&quot;0000001&quot;</span>);</span><br><span class="line">jsonMap.put(<span class="string">&quot;pic&quot;</span>,<span class="string">&quot;http://www.pic.cn/book/0000001.jpg&quot;</span>);</span><br><span class="line">jsonMap.put(<span class="string">&quot;createTime&quot;</span>, System.currentTimeMillis());</span><br><span class="line">jsonMap.put(<span class="string">&quot;price&quot;</span>, <span class="number">60.50</span>);</span><br><span class="line"><span class="comment">//索引请求对象 指定索引</span></span><br><span class="line"><span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">indexRequest.source(jsonMap);</span><br><span class="line"><span class="type">IndexResponse</span> <span class="variable">indexResponse</span> <span class="operator">=</span> restHighLevelClient.index(indexRequest, RequestOptions.DEFAULT);</span><br><span class="line">DocWriteResponse.<span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> indexResponse.getResult();</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>准备多条数据供查询使用</p><h2 id="ES-搜索-API"><a href="#ES-搜索-API" class="headerlink" title="ES 搜索 API"></a>ES 搜索 API</h2><h3 id="查询所有文档"><a href="#查询所有文档" class="headerlink" title="查询所有文档"></a>查询所有文档</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSearchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">   <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">   searchSourceBuilder.query(QueryBuilders.matchAllQuery());</span><br><span class="line">   <span class="comment">//source 源字段过虑 只查询 name 和 price </span></span><br><span class="line">   searchSourceBuilder.fetchSource(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;price&quot;</span>&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;&#125;);</span><br><span class="line">   searchRequest.source(searchSourceBuilder);</span><br><span class="line">   <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> restHighLevelClient.search(searchRequest,RequestOptions.DEFAULT);</span><br><span class="line">   <span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> searchResponse.getHits();</span><br><span class="line">   SearchHit[] searchHits = hits.getHits();</span><br><span class="line">   <span class="keyword">for</span> (SearchHit hit : searchHits) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">index</span> <span class="operator">=</span> hit.getIndex();</span><br><span class="line">      <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> hit.getId();</span><br><span class="line">      <span class="type">float</span> <span class="variable">score</span> <span class="operator">=</span> hit.getScore();</span><br><span class="line">      <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">      Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) sourceAsMap.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">      <span class="type">Double</span> <span class="variable">price</span> <span class="operator">=</span> (Double) sourceAsMap.get(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">      <span class="comment">// 因为只查 name 和 price ，所以 desc 是 null</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> (String) sourceAsMap.get(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">      System.out.println(name);</span><br><span class="line">      System.out.println(price);</span><br><span class="line">      System.out.println(desc);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>ES 分页查询传入两个参数 from 和 size</p><p>from: 表示起始文档的下表，从 0 开始。</p><p>size: 查询的文档数量</p><p>在项目中，分页时经常传入两个参数，pageNum（当前页）和 pageSize（每页数量）</p><p>在 ES 中的对应关系：</p><blockquote><p>from &#x3D;  (pageNum - 1) * pageSize;</p><p>size &#x3D; pageSize;</p></blockquote><p>java 代码：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;book&quot;</span>);</span><br><span class="line"><span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.matchAllQuery());</span><br><span class="line"><span class="comment">// 分页查询</span></span><br><span class="line">searchSourceBuilder.from(<span class="number">0</span>).size(<span class="number">1</span>);</span><br><span class="line">searchRequest.source(searchSourceBuilder);</span><br><span class="line"><span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> restHighLevelClient.search(searchRequest,RequestOptions.DEFAULT);</span><br><span class="line"><span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> searchResponse.getHits();</span><br><span class="line">SearchHit[] searchHits = hits.getHits();</span><br><span class="line"><span class="comment">// 总数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> hits.getTotalHits().value;</span><br><span class="line">System.out.println(total);</span><br><span class="line"><span class="keyword">for</span> (SearchHit hit : searchHits) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">index</span> <span class="operator">=</span> hit.getIndex();</span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> hit.getId();</span><br><span class="line"><span class="type">float</span> <span class="variable">score</span> <span class="operator">=</span> hit.getScore();</span><br><span class="line"><span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) sourceAsMap.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> (String) sourceAsMap.get(<span class="string">&quot;desc&quot;</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line">System.out.println(desc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><em><strong>关于 ES 深分页问题</strong></em></p><p>查询 ES 每次查询命中数据量不大的情况下，from&amp;size 这种方式即可满足要求，比如我们用户在查询订单时每页就显示 10 条，每个用户的订单量也不是很多，用 from&amp;size 足够了。</p><p>如果每次查询命中的数据量大的话，from&amp;size 这种方式查询的分页越深，性能越差，比如当 from&#x3D;10000,size &#x3D; 100，这这时候就需要从每个分片上查询出 10100 条数据，然后汇总计算出前 100 条，分片数越多查询压力越大。</p><p>ES 为了避免深分页，不允许使用分页(from&amp;size)查询10000（index.max_result_window:10000）条以后的数据，这时可以用 scroll 游标方式来查询，具体看业务需求。</p><h3 id="Term-Query"><a href="#Term-Query" class="headerlink" title="Term Query"></a>Term Query</h3><p>Term Query为精确查询，在搜索时会整体匹配关键字，不再将关键字分词。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTerm</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">   <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">   <span class="comment">// 查询 name 字段中包括 &#x27;虚拟机&#x27; 的所有文档</span></span><br><span class="line">   searchSourceBuilder.query(QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;虚拟机&quot;</span>));</span><br><span class="line">   searchRequest.source(searchSourceBuilder);</span><br><span class="line">   ......</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></div><h3 id="根据-id-精确匹配"><a href="#根据-id-精确匹配" class="headerlink" title="根据 id 精确匹配"></a>根据 id 精确匹配</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`List&lt;String&gt; ids = Lists.newArrayList(<span class="string">&quot;Hv6rqm4B068QQUwT7fJl&quot;</span>, <span class="string">&quot;H_6_qm4B068QQUwT9PK9&quot;</span>);</span><br><span class="line">searchSourceBuilder.query(QueryBuilders.termsQuery(<span class="string">&quot;_id&quot;</span>,ids));</span><br></pre></td></tr></table></figure></div><h3 id="match-query"><a href="#match-query" class="headerlink" title="match query"></a>match query</h3><p>match Query即全文检索，它的搜索方式是先将搜索字符串分词，再使用各各词条从索引中搜索。</p><p>match query与Term query区别是match query在搜索前先将搜索关键字分词，再拿各各词语去索引中搜索。</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">&quot;desc&quot;</span>, <span class="string">&quot;深入理解&quot;</span>).operator(Operator.OR));</span><br></pre></td></tr></table></figure></div><p>operator 设置为 or 表示搜索关键字分词后只要有一个词匹配成功就返回该文档。</p><p>operator 设置为 and 表示所有分词都匹配成功才返回。</p><h4 id="minimum-should-match："><a href="#minimum-should-match：" class="headerlink" title="minimum_should_match："></a>minimum_should_match：</h4><p>上边使用的operator &#x3D; or表示只要有一个词匹配上就得分，如果实现三个分词至少有两个词匹配如何实现?</p><p>使用minimum_should_match可以指定文档匹配词的占比:</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">&quot;desc&quot;</span>, <span class="string">&quot;深入理解虚拟机&quot;</span>).minimumShouldMatch(<span class="string">&quot;80%&quot;</span>));</span><br></pre></td></tr></table></figure></div><p>“深入理解虚拟机” 可能被分为三个词：深入、理解、虚拟机，minimum_should_match &#x3D; 80% 表示 3*0.8 &#x3D; 2.4，取整为 2，表示这三个词中至少要有两个词匹配才返回文档。</p><h3 id="multi-Query"><a href="#multi-Query" class="headerlink" title="multi Query"></a>multi Query</h3><p>multi Query 允许我们将关键字去多个字段中去查询</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去 name 和 desc 两个字段查询，并将 name 字段权重提升 10 倍，name 中包括 &#x27;虚拟机&#x27; 的排在前面</span></span><br><span class="line">searchSourceBuilder.query(QueryBuilders.multiMatchQuery(<span class="string">&quot;虚拟机&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;desc&quot;</span>).field(<span class="string">&quot;name&quot;</span>,<span class="number">10</span>));</span><br></pre></td></tr></table></figure></div><h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>布尔查询包括三种：</p><p>must: 相当于 与</p><p>should: 相当于 或</p><p>mustNot: 相当于 非</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询 name 里不包含 虚拟机 的文档</span></span><br><span class="line"><span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">boolQueryBuilder.mustNot(QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虚拟机&quot;</span>));</span><br><span class="line">searchSourceBuilder.query(boolQueryBuilder);</span><br></pre></td></tr></table></figure></div><p>布尔查询也可以支持嵌套</p><p>boolQueryBuilder1.must(boolQueryBuilder2.should(…))</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BoolQueryBuilder</span> <span class="variable">boolQueryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line"><span class="comment">// 查询价格小于等于 80 的文档</span></span><br><span class="line">boolQueryBuilder.must(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lte(<span class="number">80</span>));</span><br></pre></td></tr></table></figure></div><blockquote><p>lt:小于</p><p>lte:小于等于</p><p>gt:大于</p><p>gte:大于等于</p></blockquote><h1 id="Elasticsearch-安全防护"><a href="#Elasticsearch-安全防护" class="headerlink" title="Elasticsearch 安全防护"></a>Elasticsearch 安全防护</h1><p>目前搭建的 es 是没有任何安全认证的，也就是说只要知道了 es 的地址和端口就可以通过客户端或 head 插件来篡改、删除 es 的数据，这是不安全的，在 ES 7.x 之前，一般最多的安全防护做法是通过 nginx 转发 http 请求到 es，安全在 nginx 上做，但是这样无疑又增加了 nginx 的依赖。</p><h2 id="X-Pack"><a href="#X-Pack" class="headerlink" title="X-Pack"></a>X-Pack</h2><p>X-Pack是Elastic Stack扩展功能，提供安全性，警报，监视，报告，机器学习和许多其他功能。 ES7.0+之后，默认情况下，当安装Elasticsearch时，会自带X-Pack，无需单独再安装。</p><p>自6.8以及7.1+版本之后，基础级安全永久免费。基础级包括了认证、授权，足够我们使用了，所以建议将 es 升级到 7.x 版本。</p><h3 id="使用-X-Pack"><a href="#使用-X-Pack" class="headerlink" title="使用 X-Pack"></a>使用 X-Pack</h3><p>在节点的 elasticsearch.yml 配置文件中添加：</p><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></div><p>加密集群节点之间的通信</p><blockquote><ol><li><p>证书实现加密通信的原理：TLS需要X.509证书（X.509 证书是一个数字证书，它使用 X.509 公有密钥基础设施标准将公有密钥与证书中包含的身份相关联。X.509 证书由一家名为证书颁发机构 (CA) 的可信实体颁发。CA 持有一个或多个名为 CA 证书的特殊证书，它使用这种证书来颁发 X.509 证书。只有证书颁发机构才有权访问 CA 证书）才能对与之通信的应用程序执行加密和身份验证。 为了使节点之间的通信真正安全，<code>必须对证书进行验证</code>。</p><p>在Elasticsearch集群中验证证书真实性的推荐方法是信任签署证书的证书颁发机构（CA）。</p><p>这样，只需要使用由同一CA签名的证书，即可自动允许该节点加入集群。</p></li><li><p>借助 bin 目录下 elasticsearch-certutil 命令生成证书</p><p>.&#x2F;elasticsearch-certutil ca -out config&#x2F;elastic-certificates.p12 -pass “”</p><ol start="3"><li>elasticsearch.yml 配置节点间加密通信：</li></ol></li></ol><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt;#</span> <span class="string">加密集群节点之间的通信</span></span><br><span class="line">   <span class="attr">xpack.security.transport.ssl.enabled:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">xpack.security.transport.ssl.verification_mode:</span> <span class="string">certificate</span></span><br><span class="line">   <span class="attr">xpack.security.transport.ssl.keystore.path:</span> <span class="string">elastic-certificates.p12</span></span><br><span class="line">   <span class="attr">xpack.security.transport.ssl.truststore.path:</span> <span class="string">elastic-certificates.p12</span></span><br></pre></td></tr></table></figure></div><ol start="4"><li>设置集群密码</li></ol><p>借助 bin 目录下 elasticsearch-setup-passwords 设置集群密码：</p>   <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;elasticsearch-setup-passwords auto // 为 es 自带的用户自动生成随机密码</span><br><span class="line">   elasticsearch-setup-passwords interactive // 自定义密码（推荐）</span><br></pre></td></tr></table></figure></div><p>   elastic 账户是 es 的管理员账户，可以用它创建其他用户，并根据项目需要分配角色和权限。</p></blockquote><p>X-Pack 如何为集群设置密码？</p><p>最简单的方法， 假定是初始部署集群阶段。</p><blockquote><p>1.清空data文件（防止冲突）</p><p>2.将配置好的带证书的文件copy到另一台机器</p><p>3.根据集群配置ip、角色等信息即可</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们建立一个网站或者应用程序，经常用到搜索功能，我们自己实现复杂的搜索且性能强大、高可用、运行速度快是非常困难的，Elasticsearch</summary>
      
    
    
    
    <category term="搜索引擎" scheme="http://example.com/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="elasticsearch" scheme="http://example.com/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Collectors.toMap 方法报空指针</title>
    <link href="http://example.com/2019/03/30/java/CollectorstoMapNPE/"/>
    <id>http://example.com/2019/03/30/java/CollectorstoMapNPE/</id>
    <published>2019-03-30T10:01:54.000Z</published>
    <updated>2023-11-17T11:37:37.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>开发中经常遇到将 List 集合转 map 的时候，Java8 的 Stream API  可以简化这一操作，减少代码：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; persons = ...</span><br><span class="line"><span class="comment">// 将 Person 的 id 作为 key, value 是 name， 当 key 重复时，取第一个（不加这个的话如果 key 重复会报错）</span></span><br><span class="line">Map&lt;Integer, String&gt; idNameMap = persons.stream().collect(Collectors.toMap(Person::getId, Person::getName, (k1, k2) -&gt; k1));</span><br></pre></td></tr></table></figure></div><p>代码看着没问题，但是当某个 Person 的 name 是 null 时，会发生 NPE 异常：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException</span><br><span class="line">at java.util.HashMap.merge(HashMap.java:<span class="number">1225</span>)</span><br><span class="line">at java.util.stream.Collectors.lambda$toMap$<span class="number">58</span>(Collectors.java:<span class="number">1320</span>)</span><br><span class="line">at java.util.stream.ReduceOps$3ReducingSink.accept(ReduceOps.java:<span class="number">169</span>)</span><br><span class="line">at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:<span class="number">1382</span>)</span><br><span class="line">at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:<span class="number">481</span>)</span><br><span class="line">at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:<span class="number">471</span>)</span><br><span class="line">at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:<span class="number">708</span>)</span><br><span class="line">at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="number">234</span>)</span><br><span class="line">at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:<span class="number">499</span>)</span><br></pre></td></tr></table></figure></div><p>这是因为 List 转 Map 时，使用的 HashMap 的 merge 方法，如果 Map 的 value 为 null，那么就会报 NPE，查看源码：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">merge</span><span class="params">(K key, V value, BiFunction&lt;? <span class="built_in">super</span> V, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction&#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></div><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; idNameMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">persons.forEach(p -&gt; idNameMap.put(p.getId(), p.getName()));</span><br></pre></td></tr></table></figure></div><h3 id="Stream重写了-collect-方法"><a href="#Stream重写了-collect-方法" class="headerlink" title="Stream重写了 collect 方法"></a>Stream重写了 collect 方法</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; idNameMap = persons.stream().collect(HashMap::<span class="keyword">new</span>, (map, p) -&gt; map.put(p.getId(), p.getName()), HashMap::putAll);</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;开发中经常遇到将 List 集合转 map 的时候，Java8 的 Stream API  可以简化这一操作，减少代码：&lt;/p&gt;
&lt;div </summary>
      
    
    
    
    <category term="Java技术" scheme="http://example.com/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Golang错误和异常处理的正确姿势（转）</title>
    <link href="http://example.com/2019/03/16/go/best-practice-for-handling-ex-error/"/>
    <id>http://example.com/2019/03/16/go/best-practice-for-handling-ex-error/</id>
    <published>2019-03-16T10:01:54.000Z</published>
    <updated>2023-11-17T11:37:37.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>错误和异常是两个不同的概念，非常容易混淆。很多程序员习惯将一切非正常情况都看做错误，而不区分错误和异常，即使程序中可能有异常抛出，也将异常及时捕获并转换成错误。从表面上看，一切皆错误的思路更简单，而异常的引入仅仅增加了额外的复杂度。<br> 但事实并非如此。众所周知，Golang遵循“少即是多”的设计哲学，追求简洁优雅，就是说如果异常价值不大，就不会将异常加入到语言特性中。</p><p>错误和异常处理是程序的重要组成部分，我们先看看下面几个问题：</p><ol><li>错误和异常如何区分？</li><li>错误处理的方式有哪几种？</li><li>什么时候需要使用异常终止程序？</li><li>什么时候需要捕获异常？</li><li>…</li></ol><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>错误指的是可能出现问题的地方出现了问题，比如打开一个文件时失败，这种情况在人们的意料之中 ；而异常指的是不应该出现问题的地方出现了问题，比如引用了空指针，这种情况在人们的意料之外。可见，<strong>错误是业务过程的一部分，而异常不是</strong> 。</p><p>Golang中引入error接口类型作为错误处理的标准模式，如果函数要返回错误，则返回值类型列表中肯定包含error。error处理过程类似于C语言中的错误码，可逐层返回，直到被处理。</p><p>Golang中引入两个内置函数panic和recover来触发和终止异常处理流程，同时引入关键字defer来延迟执行defer后面的函数。<br> 一直等到包含defer语句的函数执行完毕时，延迟函数（defer后的函数）才会被执行，而不管包含defer语句的函数是通过return的正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。<br> 当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数等。如果一路在延迟函数中没有recover函数的调用，则会到达该携程的起点，该携程结束，然后终止其他所有携程，包括主携程（类似于C语言中的主线程，该携程ID为1）。</p><p>错误和异常从Golang机制上讲，就是error和panic的区别。很多其他语言也一样，比如C++&#x2F;Java，没有error但有errno，没有panic但有throw。</p><p>Golang错误和异常是可以互相转换的：</p><ol><li>错误转异常，比如程序逻辑上尝试请求某个URL，最多尝试三次，尝试三次的过程中请求失败是错误，尝试完第三次还不成功的话，失败就被提升为异常了。</li><li>异常转错误，比如panic触发的异常被recover恢复后，将返回值中error类型的变量进行赋值，以便上层函数继续走错误处理流程。</li></ol><h2 id="一个启示"><a href="#一个启示" class="headerlink" title="一个启示"></a>一个启示</h2><p>regexp包中有两个函数Compile和MustCompile，它们的声明如下：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(expr <span class="type">string</span>)</span></span> (*Regexp, <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MustCompile</span><span class="params">(str <span class="type">string</span>)</span></span> *Regexp</span><br></pre></td></tr></table></figure></div><p>同样的功能，不同的设计：</p><ol><li>Compile函数基于错误处理设计，将正则表达式编译成有效的可匹配格式，适用于用户输入场景。当用户输入的正则表达式不合法时，该函数会返回一个错误。</li><li>MustCompile函数基于异常处理设计，适用于硬编码场景。当调用者明确知道输入不会引起函数错误时，要求调用者检查这个错误是不必要和累赘的。我们应该假设函数的输入一直合法，当调用者输入了不应该出现的输入时，就触发panic异常。</li></ol><p>于是我们得到一个启示：<strong>什么情况下用错误表达，什么情况下用异常表达，就得有一套规则，否则很容易出现一切皆错误或一切皆异常的情况。</strong></p><p>在这个启示下，我们给出异常处理的作用域（场景）：</p><ol><li>空指针引用</li><li>下标越界</li><li>除数为0</li><li>不应该出现的分支，比如default</li><li>输入不应该引起函数错误</li></ol><p>其他场景我们使用错误处理，这使得我们的函数接口很精炼。对于异常，我们可以选择在一个合适的上游去recover，并打印堆栈信息，使得部署后的程序不会终止。</p><p><strong>说明： Golang错误处理方式一直是很多人诟病的地方，有些人吐槽说一半的代码都是”if err !&#x3D; nil { &#x2F; 打印 &amp;&amp; 错误处理 &#x2F; }”，严重影响正常的处理逻辑。当我们区分错误和异常，根据规则设计函数，就会大大提高可读性和可维护性。</strong></p><h2 id="错误处理的正确姿势"><a href="#错误处理的正确姿势" class="headerlink" title="错误处理的正确姿势"></a>错误处理的正确姿势</h2><h3 id="姿势一：失败的原因只有一个时，不使用error"><a href="#姿势一：失败的原因只有一个时，不使用error" class="headerlink" title="姿势一：失败的原因只有一个时，不使用error"></a>姿势一：失败的原因只有一个时，不使用error</h3><p>我们看一个案例：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *AgentContext)</span></span> CheckHostType(host_type <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> host_type &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;virtual_machine&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;bare_metal&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;CheckHostType ERROR:&quot;</span> + host_type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们可以看出，该函数失败的原因只有一个，所以返回值的类型应该为bool，而不是error，重构一下代码：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *AgentContext)</span></span> IsValidHostType(hostType <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hostType == <span class="string">&quot;virtual_machine&quot;</span> || hostType == <span class="string">&quot;bare_metal&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>说明：大多数情况，导致失败的原因不止一种，尤其是对I&#x2F;O操作而言，用户需要了解更多的错误信息，这时的返回值类型不再是简单的bool，而是error。</p><h3 id="姿势二：没有失败时，不使用error"><a href="#姿势二：没有失败时，不使用error" class="headerlink" title="姿势二：没有失败时，不使用error"></a>姿势二：没有失败时，不使用error</h3><p>error在Golang中是如此的流行，以至于很多人设计函数时不管三七二十一都使用error，即使没有一个失败原因。<br> 我们看一下示例代码：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *CniParam)</span></span> setTenantId() <span class="type">error</span> &#123;</span><br><span class="line">    self.TenantId = self.PodNs</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>对于上面的函数设计，就会有下面的调用代码：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err := self.setTenantId()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// log</span></span><br><span class="line">    <span class="comment">// free resource</span></span><br><span class="line">    <span class="keyword">return</span> errors.New(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>根据我们的正确姿势，重构一下代码：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *CniParam)</span></span> setTenantId() &#123;</span><br><span class="line">    self.TenantId = self.PodNs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>于是调用代码变为：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.setTenantId()</span><br></pre></td></tr></table></figure></div><h3 id="姿势三：error应放在返回值类型列表的最后"><a href="#姿势三：error应放在返回值类型列表的最后" class="headerlink" title="姿势三：error应放在返回值类型列表的最后"></a>姿势三：error应放在返回值类型列表的最后</h3><p>对于返回值类型error，用来传递错误信息，在Golang中通常放在最后一个。</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nill, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>bool作为返回值类型时也一样。</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value, ok := cache.Lookup(key) </span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="comment">// ...cache[key] does not exist… </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="姿势四：错误值统一定义，而不是跟着感觉走"><a href="#姿势四：错误值统一定义，而不是跟着感觉走" class="headerlink" title="姿势四：错误值统一定义，而不是跟着感觉走"></a>姿势四：错误值统一定义，而不是跟着感觉走</h3><p>很多人写代码时，到处return errors.New(value)，而错误value在表达同一个含义时也可能形式不同，比如“记录不存在”的错误value可能为：</p><ol><li>“record is not existed.”</li><li>“record is not exist!”</li><li>“###record is not existed！！！”</li><li>…</li></ol><p>这使得相同的错误value撒在一大片代码里，当上层函数要对特定错误value进行统一处理时，需要漫游所有下层代码，以保证错误value统一，不幸的是有时会有漏网之鱼，而且这种方式严重阻碍了错误value的重构。</p><p>于是，我们可以参考C&#x2F;C++的错误码定义文件，在Golang的每个包中增加一个错误对象定义文件，如下所示：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ERR_EOF = errors.New(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> ERR_CLOSED_PIPE = errors.New(<span class="string">&quot;io: read/write on closed pipe&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> ERR_NO_PROGRESS = errors.New(<span class="string">&quot;multiple Read calls return no data or error&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> ERR_SHORT_BUFFER = errors.New(<span class="string">&quot;short buffer&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> ERR_SHORT_WRITE = errors.New(<span class="string">&quot;short write&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> ERR_UNEXPECTED_EOF = errors.New(<span class="string">&quot;unexpected EOF&quot;</span>)</span><br></pre></td></tr></table></figure></div><p>说明：笔者对于常量更喜欢C&#x2F;C++的“全大写+下划线分割”的命名方式，读者可以根据团队的命名规范或个人喜好定制。</p><h3 id="姿势五：错误逐层传递时，层层都加日志"><a href="#姿势五：错误逐层传递时，层层都加日志" class="headerlink" title="姿势五：错误逐层传递时，层层都加日志"></a>姿势五：错误逐层传递时，层层都加日志</h3><p>根据笔者经验，层层都加日志非常方便故障定位。</p><p>说明：至于通过测试来发现故障，而不是日志，目前很多团队还很难做到。如果你或你的团队能做到，那么请忽略这个姿势:)</p><h3 id="姿势六：错误处理使用defer"><a href="#姿势六：错误处理使用defer" class="headerlink" title="姿势六：错误处理使用defer"></a>姿势六：错误处理使用defer</h3><p>我们一般通过判断error的值来处理错误，如果当前操作失败，需要将本函数中已经create的资源destroy掉，示例代码如下：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferDemo</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    err := createResource1()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE1_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    err = createResource2()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        destroyResource1()</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE2_FAILED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = createResource3()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        destroyResource1()</span><br><span class="line">        destroyResource2()</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE3_FAILED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = createResource4()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        destroyResource1()</span><br><span class="line">        destroyResource2()</span><br><span class="line">        destroyResource3()</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE4_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>当Golang的代码执行时，如果遇到defer的闭包调用，则压入堆栈。当函数返回时，会按照后进先出的顺序调用闭包。<br> <strong>对于闭包的参数是值传递，而对于外部变量却是引用传递，所以闭包中的外部变量err的值就变成外部函数返回时最新的err值。</strong><br> 根据这个结论，我们重构上面的示例代码：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferDemo</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    err := createResource1()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE1_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            destroyResource1()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    err = createResource2()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE2_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            destroyResource2()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err = createResource3()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE3_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            destroyResource3()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err = createResource4()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE4_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="姿势七：当尝试几次可以避免失败时，不要立即返回错误"><a href="#姿势七：当尝试几次可以避免失败时，不要立即返回错误" class="headerlink" title="姿势七：当尝试几次可以避免失败时，不要立即返回错误"></a>姿势七：当尝试几次可以避免失败时，不要立即返回错误</h3><p>如果错误的发生是偶然性的，或由不可预知的问题导致。一个明智的选择是重新尝试失败的操作，有时第二次或第三次尝试时会成功。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。</p><p>两个案例：</p><ol><li>我们平时上网时，尝试请求某个URL，有时第一次没有响应，当我们再次刷新时，就有了惊喜。</li><li>团队的一个QA曾经建议当Neutron的attach操作失败时，最好尝试三次，这在当时的环境下验证果然是有效的。</li></ol><h3 id="姿势八：当上层函数不关心错误时，建议不返回error"><a href="#姿势八：当上层函数不关心错误时，建议不返回error" class="headerlink" title="姿势八：当上层函数不关心错误时，建议不返回error"></a>姿势八：当上层函数不关心错误时，建议不返回error</h3><p>对于一些资源清理相关的函数（destroy&#x2F;delete&#x2F;clear），如果子函数出错，打印日志即可，而无需将错误进一步反馈到上层函数，因为一般情况下，上层函数是不关心执行结果的，或者即使关心也无能为力，于是我们建议将相关函数设计为不返回error。</p><h3 id="姿势九：当发生错误时，不忽略有用的返回值"><a href="#姿势九：当发生错误时，不忽略有用的返回值" class="headerlink" title="姿势九：当发生错误时，不忽略有用的返回值"></a>姿势九：当发生错误时，不忽略有用的返回值</h3><p>通常，当函数返回non-nil的error时，其他的返回值是未定义的(undefined)，这些未定义的返回值应该被忽略。然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，应该将读取到的字符串和错误信息一起打印出来。</p><p><strong>说明：对函数的返回值要有清晰的说明，以便于其他人使用。</strong></p><h2 id="异常处理的正确姿势"><a href="#异常处理的正确姿势" class="headerlink" title="异常处理的正确姿势"></a>异常处理的正确姿势</h2><h3 id="姿势一：在程序开发阶段，坚持速错"><a href="#姿势一：在程序开发阶段，坚持速错" class="headerlink" title="姿势一：在程序开发阶段，坚持速错"></a>姿势一：在程序开发阶段，坚持速错</h3><p>去年学习Erlang的时候，建立了速错的理念，简单来讲就是“让它挂”，只有挂了你才会第一时间知道错误。在早期开发以及任何发布阶段之前，最简单的同时也可能是最好的方法是调用panic函数来中断程序的执行以强制发生错误，使得该错误不会被忽略，因而能够被尽快修复。</p><h3 id="姿势二：在程序部署后，应恢复异常避免程序终止"><a href="#姿势二：在程序部署后，应恢复异常避免程序终止" class="headerlink" title="姿势二：在程序部署后，应恢复异常避免程序终止"></a>姿势二：在程序部署后，应恢复异常避免程序终止</h3><p>在Golang中，虽然有类似Erlang进程的Goroutine，但需要强调的是Erlang的挂，只是Erlang进程的异常退出，不会导致整个Erlang节点退出，所以它挂的影响层面比较低，而Goroutine如果panic了，并且没有recover，那么整个Golang进程（类似Erlang节点）就会异常退出。所以，一旦Golang程序部署后，在任何情况下发生的异常都不应该导致程序异常退出，我们在上层函数中加一个延迟执行的recover调用来达到这个目的，并且是否进行recover需要根据环境变量或配置文件来定，默认需要recover。<br> 这个姿势类似于C语言中的断言，但还是有区别：一般在Release版本中，断言被定义为空而失效，但需要有if校验存在进行异常保护，尽管契约式设计中不建议这样做。在Golang中，recover完全可以终止异常展开过程，省时省力。</p><p>我们在调用recover的延迟函数中以最合理的方式响应该异常：</p><ol><li>打印堆栈的异常调用信息和关键的业务信息，以便这些问题保留可见；</li><li>将异常转换为错误，以便调用者让程序恢复到健康状态并继续安全运行。</li></ol><p>我们看一个简单的例子：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;panic recover! p: %v&quot;</span>, p)</span><br><span class="line">            debug.PrintStack()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> funcB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// simulation</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := funcA()</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;err is nil\\n&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;err is %v\\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们期望test函数的输出是：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err is foo</span><br></pre></td></tr></table></figure></div><p>实际上test函数的输出是：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err is nil</span><br></pre></td></tr></table></figure></div><p>原因是panic异常处理机制不会自动将错误信息传递给error，所以要在funcA函数中进行显式的传递，代码如下所示：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;panic recover! p:&quot;</span>, p)</span><br><span class="line">            str, ok := p.(<span class="type">string</span>)</span><br><span class="line">            <span class="keyword">if</span> ok &#123;</span><br><span class="line">                err = errors.New(str)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                err = errors.New(<span class="string">&quot;panic&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            debug.PrintStack()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> funcB()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="姿势三：对于不应该出现的分支，使用异常处理"><a href="#姿势三：对于不应该出现的分支，使用异常处理" class="headerlink" title="姿势三：对于不应该出现的分支，使用异常处理"></a>姿势三：对于不应该出现的分支，使用异常处理</h3><p>当某些不应该发生的场景发生时，我们就应该调用panic函数来触发异常。比如，当程序到达了某条逻辑上不可能到达的路径：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> s := suit(drawCard()); s &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Spades&quot;</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Hearts&quot;</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Diamonds&quot;</span>:</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Clubs&quot;</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;invalid suit %v&quot;</span>, s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="姿势四：针对入参不应该有问题的函数，使用panic设计"><a href="#姿势四：针对入参不应该有问题的函数，使用panic设计" class="headerlink" title="姿势四：针对入参不应该有问题的函数，使用panic设计"></a>姿势四：针对入参不应该有问题的函数，使用panic设计</h3><p>入参不应该有问题一般指的是硬编码，我们先看“一个启示”一节中提到的两个函数（Compile和MustCompile），其中MustCompile函数是对Compile函数的包装：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MustCompile</span><span class="params">(str <span class="type">string</span>)</span></span> *Regexp &#123;</span><br><span class="line">    regexp, <span class="type">error</span> := Compile(str)</span><br><span class="line">    <span class="keyword">if</span> <span class="type">error</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">`regexp: Compile(`</span> + quote(str) + <span class="string">`): `</span> + <span class="type">error</span>.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regexp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>所以，对于同时支持用户输入场景和硬编码场景的情况，一般支持硬编码场景的函数是对支持用户输入场景函数的包装。<br> 对于只支持硬编码单一场景的情况，函数设计时直接使用panic，即返回值类型列表中不会有error，这使得函数的调用处理非常方便（没有了乏味的”if err !&#x3D; nil {&#x2F; 打印 &amp;&amp; 错误处理 &#x2F;}”代码块）。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文以Golang为例，阐述了错误和异常的区别，并且分享了很多错误和异常处理的正确姿势，这些姿势可以单独使用，也可以组合使用，希望对大家有一点启发。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;错误和异常是两个不同的概念，非常容易混淆。很多程序员习惯将一切非正常情况都看做错误，而不区分错误和异常，即使程序中可能有异常抛出，也将异常及</summary>
      
    
    
    
    <category term="Go" scheme="http://example.com/categories/Go/"/>
    
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Golang初学者易犯的三种错误（转）</title>
    <link href="http://example.com/2019/03/15/go/three-mistakes/"/>
    <id>http://example.com/2019/03/15/go/three-mistakes/</id>
    <published>2019-03-15T10:01:54.000Z</published>
    <updated>2023-11-17T11:37:37.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>笔者学习并使用Golang已经有一个多月了，尽管Golang的特性少、语法简单且功能强大，但作为初学者，难免会犯一些大家都犯过的错误。笔者在实践的基础上，将初学者易犯的错误进行了简单梳理，暂时总结了三种错误，先分享给大家，希望对大家有一定的帮助。</p><h2 id="资源关闭"><a href="#资源关闭" class="headerlink" title="资源关闭"></a>资源关闭</h2><p>这里的资源包括文件、数据库连接和Socket连接等，我们以文件操作为例，说明一下常见的资源关闭错误。</p><p>文件操作的一个代码示例：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">&quot;test.go&quot;</span>) </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open file failed:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>一些同学写到这就开始专注业务代码了，最后“忘记”了写关闭文件操作的代码。殊不知，这里埋下了一个祸根。在Linux中，一切皆文件，当打开的文件数过多时，就会触发”too many open files“的系统错误，从而让整个系统陷入崩溃。</p><p>我们增加上关闭文件操作的代码，如下所示：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open file failed:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>Golang提供了一个很好用的关键字defer，defer语句的含义是不管程序是否出现异常，均在函数退出时自动执行相关代码。遗憾的是，上面的修改又引入了新问题，即如果文件打开错误，调用file.Close会导致程序抛出异常（panic），所以正确的修改应该将file.Close放到错误检查之后，如下：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">&quot;test.go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;open file failed:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><h2 id="变量的大小写"><a href="#变量的大小写" class="headerlink" title="变量的大小写"></a>变量的大小写</h2><p>Golang对关键字的增加非常吝啬，其中没有private、protected和public这样的关键字。要使某个符号对其他包（package）可见（即可以访问），需要将该符号定义为以大写字母开头，这些符号包括接口，类型，函数和变量等。</p><p>对于那些比较在意美感的程序员，尤其是工作在Linux平台上的C&#x2F;C++程序员，函数名或变量名以大写字母开头可能会让他们感觉不太适应，同时他们严格遵循最小可见性的原则，接口名和类名以小写字母开头也会让他们很纠结。在他们自己写代码的时候可能会顺手将函数名或变量名改成以小写字母开头，当与小写字母开头的接口名或类型名冲突时（包内可见性），还得费心的另外想一个名字。如果不小心，将包外可见性的符号rename成了以小写字母开头，则会遇到编译错误，即明明有符号却偏偏找不到，不过这对于有一些编程经验的程序员来说还是比较好解决的。</p><p>下面的例子对于Golang的初学者，即使有一些编程经验，也较难排查，往往要花费稍微多一些的时间。</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Position <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="type">int</span> </span><br><span class="line">    Y <span class="type">int</span></span><br><span class="line">    Z <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Sex <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    position Position</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    position1 := Position&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">    student1 := Student&#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;male&quot;</span>, <span class="number">20</span>, position1&#125;</span><br><span class="line">    position2 := Position&#123;<span class="number">15</span>, <span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">    student2 := Student&#123;<span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;female&quot;</span>, <span class="number">18</span>, position2&#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> srcSlice = <span class="built_in">make</span>([]Student, <span class="number">2</span>)</span><br><span class="line">    srcSlice[<span class="number">0</span>] = student1</span><br><span class="line">    srcSlice[<span class="number">1</span>] = student2</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Init:srcSlice is : %v\n&quot;</span>, srcSlice)</span><br><span class="line">    data, err := json.Marshal(srcSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Serialize:json.Marshal error! %v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dstSliece = <span class="built_in">make</span>([]Student, <span class="number">2</span>)</span><br><span class="line">    err = json.Unmarshal(data, &amp;dstSliece)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Deserialize: json.Unmarshal error! %v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Deserialize:dstSlice is : %v\n&quot;</span>, dstSliece)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们看一下打印结果：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Init:srcSlice is : [&#123;zhangsan male <span class="number">20</span> &#123;<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>&#125;&#125; &#123;lisi female <span class="number">18</span> &#123;<span class="number">15</span> <span class="number">10</span> <span class="number">20</span>&#125;&#125;]</span><br><span class="line">Deserialize:dstSliece is : [&#123;zhangsan male <span class="number">20</span> &#123;<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>&#125;&#125; &#123;lisi female <span class="number">18</span> &#123;<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>&#125;&#125;]</span><br></pre></td></tr></table></figure></div><p>很意外的是，我们反序列化后获取的对象数据是错误的，而json.Unmarshal没有返回任何异常。<br> 为了进一步定位，我们将序列化后的json串打印出来：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serialize:data is : [&#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;Sex&quot;</span>:<span class="string">&quot;male&quot;</span>,<span class="string">&quot;Age&quot;</span>:<span class="number">20</span>&#125;,&#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;Sex&quot;</span>:<span class="string">&quot;female&quot;</span>,<span class="string">&quot;Age&quot;</span>:<span class="number">18</span>&#125;]</span><br></pre></td></tr></table></figure></div><p>从打印结果可以看出，Position的数据丢了，这使得我们想到了可见性，即大写的符号在包外可见。通过走查代码，我们发现Student的定义中，Position的变量名是小写开始的：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Sex <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    position Position</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>对于习惯写C&#x2F;C++&#x2F;Java代码的同学，修改这个变量的名字变得很纠结，以往“类名大写开头，对象名小写开头”的经验不再适用，不得不起一个不太顺溜的名字，比如缩写：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Sex <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    Posi Position</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>再次运行程序，结果正常，打印如下：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Init:srcSlice is : [&#123;zhangsan male <span class="number">20</span> &#123;<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>&#125;&#125; &#123;lisi female <span class="number">18</span> &#123;<span class="number">15</span> <span class="number">10</span> <span class="number">20</span>&#125;&#125;]</span><br><span class="line">Serialize:data is : [&#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;Sex&quot;</span>:<span class="string">&quot;male&quot;</span>,<span class="string">&quot;Age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;Posi&quot;</span>:&#123;<span class="string">&quot;X&quot;</span>:<span class="number">10</span>,<span class="string">&quot;Y&quot;</span>:<span class="number">20</span>,<span class="string">&quot;Z&quot;</span>:<span class="number">30</span>&#125;&#125;,&#123;<span class="string">&quot;Name&quot;</span>:<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;Sex&quot;</span>:<span class="string">&quot;female&quot;</span>,<span class="string">&quot;Age&quot;</span>:<span class="number">18</span>,<span class="string">&quot;Posi&quot;</span>:&#123;<span class="string">&quot;X&quot;</span>:<span class="number">15</span>,<span class="string">&quot;Y&quot;</span>:<span class="number">10</span>,<span class="string">&quot;Z&quot;</span>:<span class="number">20</span>&#125;&#125;]</span><br><span class="line">Deserialize:dstSliece is : [&#123;zhangsan male <span class="number">20</span> &#123;<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>&#125;&#125; &#123;lisi female <span class="number">18</span> &#123;<span class="number">15</span> <span class="number">10</span> <span class="number">20</span>&#125;&#125;]</span><br></pre></td></tr></table></figure></div><p>对于json串，很多人喜欢全小写，对于大写开头的key感觉很刺眼，我们继续改进：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Position <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="type">int</span> <span class="string">`json:&quot;x&quot;`</span></span><br><span class="line">    Y <span class="type">int</span> <span class="string">`json:&quot;y&quot;`</span></span><br><span class="line">    Z <span class="type">int</span> <span class="string">`json:&quot;z&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Sex <span class="type">string</span> <span class="string">`json:&quot;sex&quot;`</span></span><br><span class="line">    Age <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">    Posi Position <span class="string">`json:&quot;position&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>两个斜点之间的代码，比如<code>json:&quot;name&quot;</code>，作用是Name字段在从结构体实例编码到JSON数据格式的时候，使用name作为名字，这可以看作是一种重命名的方式。</p><p>再次运行程序，结果是我们期望的，打印如下：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Init:srcSlice is : [&#123;zhangsan male <span class="number">20</span> &#123;<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>&#125;&#125; &#123;lisi female <span class="number">18</span> &#123;<span class="number">15</span> <span class="number">10</span> <span class="number">20</span>&#125;&#125;]</span><br><span class="line">Serialize:data is : [&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;sex&quot;</span>:<span class="string">&quot;male&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">20</span>,<span class="string">&quot;position&quot;</span>:&#123;<span class="string">&quot;x&quot;</span>:<span class="number">10</span>,<span class="string">&quot;y&quot;</span>:<span class="number">20</span>,<span class="string">&quot;z&quot;</span>:<span class="number">30</span>&#125;&#125;,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;sex&quot;</span>:<span class="string">&quot;female&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>,<span class="string">&quot;position&quot;</span>:&#123;<span class="string">&quot;x&quot;</span>:<span class="number">15</span>,<span class="string">&quot;y&quot;</span>:<span class="number">10</span>,<span class="string">&quot;z&quot;</span>:<span class="number">20</span>&#125;&#125;]</span><br><span class="line">Deserialize:dstSliece is : [&#123;zhangsan male <span class="number">20</span> &#123;<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>&#125;&#125; &#123;lisi female <span class="number">18</span> &#123;<span class="number">15</span> <span class="number">10</span> <span class="number">20</span>&#125;&#125;]</span><br></pre></td></tr></table></figure></div><h2 id="局部变量初始化"><a href="#局部变量初始化" class="headerlink" title="局部变量初始化(:&#x3D;)"></a>局部变量初始化(:&#x3D;)</h2><p>Golang中有一种局部变量初始化方法，即使用冒号和等号的组合“:&#x3D;”来进行变量声明和初始化,这使得我们在使用局部变量时很方便。</p><p>初始化一个局部变量的代码可以这样写：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := <span class="number">10</span></span><br></pre></td></tr></table></figure></div><p>指定类型已不再是必需的，Go编译器可以从初始化表达式的右值推导出该变量应该声明为哪种类型，这让Go语言看起来有点像动态类型语言，尽管Go语言实际上是不折不扣的强类型语言（静态类型语言）。</p><p><strong>说明：感觉与C++11中auto关键字的作用有点类似</strong></p><p>Golang中引入了一个关于错误处理的标准模式，即error接口，大家都太爱用了，以至于明显只有bool属性的返回值或变量都用error来修饰，我们看一个例子：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">port, err := createPort()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">veth, err := createVeth()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = insert()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>这里的两个局部变量err是同一个变量吗？答案是肯定的</p><p>通过冒号和等号的组合“:&#x3D;”来进行变量初始化有一个限制，即出现在“:&#x3D;”左侧的变量至少有一个是没有声明过的，否则编译失败。</p><p>很多人不知道这个规则，则写出下面的代码:</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">port, errPort := createPort()</span><br><span class="line"><span class="keyword">if</span> errPort != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">veth, errVeth := createVeth()</span><br><span class="line"><span class="keyword">if</span> errVeth != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">errInsert := insert()</span><br><span class="line"><span class="keyword">if</span> errInsert != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>对于喜欢写简单优美代码的同学可能接受不了这样的命名，比如errPort, errVeth和errInsert等，所以对于error接口的变量命名，在笔者心中的baby names只有一个，那就是err。</p><p>除过命名，另一个常见错误是局部变量有可能遮盖或隐藏全局变量，因为通过“:&#x3D;”方式初始化的局部变量看不到全局变量。</p><p>我们先看一段代码：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;bar n:&quot;</span>, n) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n, err := foo()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">    fmt.Println(<span class="string">&quot;main n:&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这段代码的原意是定义一个包内的全局变量n，用foo函数的返回值对n进行赋值，在bar函数中使用n。<br> 预期结果是bar()和main()中均输出5，但程序运行后的结果却不是我们期望的：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar n: <span class="number">0</span></span><br><span class="line">main n: <span class="number">5</span></span><br></pre></td></tr></table></figure></div><p>通过增加打印进一步定位，发现main函数中调用foo函数后的n的地址(0x201d2210)与全局变量的n的地址(0x56b4a4)并不一样，也就是说前者是一个局部变量，同时从bar函数中的打印来看，全局变量n在foo函数返回时并未被赋值为它的返回值5，仍然是初始的默认值0。</p><p>最初对语句“n, err :&#x3D; foo()”的理解是，Golang会定义新变量err，n为初始定义的那个全局变量。但实际情况是，对于使用“:&#x3D;”定义的变量，如果新变量n与那个已同名定义的变量(这里就是那个全局变量n)不在一个作用域中时，那么Golang会新定义这个变量n，并遮盖或隐藏住大作用域的同名变量，这就是导致该问题的真凶。</p><p>知道真凶后就很好解决了，即我们用“&#x3D;”代替“:&#x3D;”：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    n, err = foo()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar()</span><br><span class="line">    fmt.Println(<span class="string">&quot;main n:&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>再次运行该程序，执行结果完全符合预期：</p><div class="highlight-container" data-rel="Go"><figure class="iseeu highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bar n: <span class="number">5</span></span><br><span class="line">main n: <span class="number">5</span></span><br></pre></td></tr></table></figure></div><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文总结了Golang初学者易犯的三种错误，包括资源关闭、符号的大小写和局部变量初始化，希望对像我一样的新手有一点帮助，从而在业务实现过程中少走一些弯路，更快更安全的面向业务编程，持续的向用户交付价值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;笔者学习并使用Golang已经有一个多月了，尽管Golang的特性少、语法简单且功能强大，但作为初学者，难免会犯一些大家都犯过的错误。笔者在</summary>
      
    
    
    
    <category term="Go" scheme="http://example.com/categories/Go/"/>
    
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>为什么我学 Go？</title>
    <link href="http://example.com/2019/03/10/go/why-i-learn-go/"/>
    <id>http://example.com/2019/03/10/go/why-i-learn-go/</id>
    <published>2019-03-10T10:01:54.000Z</published>
    <updated>2023-11-17T11:37:37.008Z</updated>
    
    <content type="html"><![CDATA[<p>就是好奇，想学，没别的原因😄</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;就是好奇，想学，没别的原因😄&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Go" scheme="http://example.com/categories/Go/"/>
    
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Java8 中 joda-time 时间操作工具常用常用 API</title>
    <link href="http://example.com/2019/01/16/java/joda-time-common-use/"/>
    <id>http://example.com/2019/01/16/java/joda-time-common-use/</id>
    <published>2019-01-16T10:01:54.000Z</published>
    <updated>2023-11-17T11:37:37.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近公司要对一个老系统进行重构、服务拆分，老系统毕竟是几年前的项目了，在重构的过程中发现代码里对日期的操作还是用的Date、Calendar、SimpleDateFormatter 等API，甚至某些地方还存在线程安全问题。</p><p>重构项目采用的是 Java8 的最新版本，所以可以使用其新特性 joda-time 来操作日期，使代码更简洁、优雅、安全。</p><h1 id="Joda-Time"><a href="#Joda-Time" class="headerlink" title="Joda-Time"></a>Joda-Time</h1><p>在 Java8 之前，日期处理是比较繁琐，令人头疼的部分，不仅是复杂的 API 操作，甚至还有线程安全问题。因此，产生了强大的 Joda-Time，可以替换 Java 日期操作的 API，Java8 吸收了Joda-Time 的精华，包含了所有关于日期、时间、日期时间、时区、Instant（跟 Date 类似但精确到纳秒）、duration（持续时间精确到秒）、Period（持续时间精确到天）和时钟操作的类，而且 Joda-Time 这些类都具有可变性，当我们修改一个时间的时候，会返回一个新的对象，这样也解决了线程安全问题。</p><h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>CLock 可以用来获取当前的 Instant 、毫秒数等：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Clock</span> <span class="variable">clock</span> <span class="operator">=</span> Clock.systemUTC();</span><br><span class="line">System.out.println(clock.millis());</span><br><span class="line">System.out.println(clock.instant());</span><br><span class="line"><span class="comment">//上海时钟</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Clock</span> <span class="variable">shanghaiClk</span> <span class="operator">=</span> Clock.system(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>查看&#96;Clock.systemUTC();<code>注释可以得知，这个可以用来替代</code>System.currentTimeMillis()&#96;&#96;来获取当前时间的毫秒数</p><h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"><span class="comment">//精确到秒 得到相对于1970-01-01 00:00:00 UTC的一个时间  </span></span><br><span class="line">System.out.println(instant.getEpochSecond());</span><br><span class="line"><span class="comment">//精确到毫秒  </span></span><br><span class="line">System.out.println(instant.toEpochMilli()); </span><br><span class="line"><span class="comment">// Instant 转 Date</span></span><br><span class="line">Date date=Date.from(instant);</span><br><span class="line"><span class="comment">// Date 转 Instant</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().toInstant();</span><br></pre></td></tr></table></figure></div><p>和 Date 类似，但是可以精确到纳秒。</p><h3 id="LocalDate、LocalTime、LocalDateTime"><a href="#LocalDate、LocalTime、LocalDateTime" class="headerlink" title="LocalDate、LocalTime、LocalDateTime"></a>LocalDate、LocalTime、LocalDateTime</h3><p>获取当地的日期和时间：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">System.out.println(localDate);</span><br><span class="line"><span class="comment">// 判断今年是否是闰年</span></span><br><span class="line">System.out.println(localDate.isLeapYear());</span><br><span class="line"><span class="comment">// 获得本月天数</span></span><br><span class="line">System.out.println(localDate.lengthOfMonth());</span><br><span class="line"></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">System.out.println(localTime);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime);</span><br></pre></td></tr></table></figure></div><p>LocalDate 只保留本地当前时间的年月日部分，LocalTIme 保存本地当前时间的后半段部分，而 LocalDateTime 则是完整的当前时间。</p><p>这三个类也可以用 of方法来构造：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">of</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2019</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">System.out.println(of);</span><br></pre></td></tr></table></figure></div><p>如果需要获得带时区的时间，可以使用 ZonedDateTime（我平时开发基本用不到）。</p><h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p>用于计算日期的间隔：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">from</span> <span class="operator">=</span> LocalDateTime.of( <span class="number">2019</span>, Month.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">to</span> <span class="operator">=</span> LocalDateTime.of( <span class="number">2019</span>, Month.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(from, to);</span><br><span class="line">System.out.println(duration.toDays());</span><br><span class="line">System.out.println(duration.toHours());</span><br></pre></td></tr></table></figure></div><p>Duration 也可以使用of来构造。</p><h3 id="日期加减等操作"><a href="#日期加减等操作" class="headerlink" title="日期加减等操作"></a>日期加减等操作</h3><p>Joda-Time 把日期的加减操作也变得非常简单、易读：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span>LocalDateTime.now();</span><br><span class="line"><span class="comment">// 加一天</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">plusDays</span> <span class="operator">=</span> localDateTime.plusDays(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 减一年</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">minusYears</span> <span class="operator">=</span> localDateTime.minusYears(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置年</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">withYear</span> <span class="operator">=</span> localDateTime.withYear(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断日期是否是同一天，判断日期先后</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">equal</span> <span class="operator">=</span> localDateTime.isEqual(withYear);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">after</span> <span class="operator">=</span> localDateTime.isAfter(withYear);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">before</span> <span class="operator">=</span> localDateTime.isBefore(withYear);</span><br></pre></td></tr></table></figure></div><h3 id="LocalDateTime-和-String-互转"><a href="#LocalDateTime-和-String-互转" class="headerlink" title="LocalDateTime 和 String 互转"></a>LocalDateTime 和 String 互转</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span>LocalDateTime.now();</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> localDateTime.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line">System.out.println(format);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;2019-03-16&quot;</span>;</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDateTime.parse(dateStr);</span><br></pre></td></tr></table></figure></div><h3 id="获取年、月、日、时、分、秒"><a href="#获取年、月、日、时、分、秒" class="headerlink" title="获取年、月、日、时、分、秒"></a>获取年、月、日、时、分、秒</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span>LocalDateTime.now();</span><br><span class="line"><span class="comment">// 年</span></span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> localDateTime.getYear();</span><br><span class="line"><span class="comment">// 月</span></span><br><span class="line"><span class="type">Month</span> <span class="variable">month</span> <span class="operator">=</span> localDateTime.getMonth();</span><br><span class="line"><span class="type">int</span> <span class="variable">monthValue</span> <span class="operator">=</span> month.getValue();</span><br><span class="line"><span class="comment">// 日</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> localDateTime.getDayOfMonth();</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="获得本月的第一天和最后一天"><a href="#获得本月的第一天和最后一天" class="headerlink" title="获得本月的第一天和最后一天"></a>获得本月的第一天和最后一天</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="comment">//本月的第一天</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">firstday</span> <span class="operator">=</span> LocalDate.of(today.getYear(),today.getMonth(),<span class="number">1</span>);</span><br><span class="line"><span class="comment">//本月的最后一天</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">lastDay</span> <span class="operator">=</span>today.with(TemporalAdjusters.lastDayOfMonth());</span><br></pre></td></tr></table></figure></div><h3 id="判断今天是否是生日"><a href="#判断今天是否是生日" class="headerlink" title="判断今天是否是生日"></a>判断今天是否是生日</h3><p>做过电商项目的话，这个需求一定很熟悉：用户生日的当天给用户发贺卡，短信生日祝福、生日促销券等，如何判断今天是不是用户的生日呢？可以使用 <code>MonthDay</code>的 API，非常简单地完成判断：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 今天</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="comment">// 生日</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">birthDay</span> <span class="operator">=</span> LocalDate.of(<span class="number">1991</span>, <span class="number">9</span>, <span class="number">28</span>);</span><br><span class="line"><span class="comment">// 使用 MonthDay 只存月、日</span></span><br><span class="line"><span class="type">MonthDay</span> <span class="variable">birthMonthday</span> <span class="operator">=</span> MonthDay.from(birthDay);</span><br><span class="line"><span class="type">MonthDay</span> <span class="variable">currentMonthDay</span> <span class="operator">=</span> MonthDay.from(today);</span><br><span class="line"><span class="keyword">if</span>(currentMonthDay.equals(birthMonthday))&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;祝你生日快乐!!&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;今年不是你的生日&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>更多丰富的 API 操作，等后面遇到了会继续补充，未完待续……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近公司要对一个老系统进行重构、服务拆分，老系统毕竟是几年前的项目了，在重构的过程中发现代码里对日期的操作还是用的Date、Calendar</summary>
      
    
    
    
    <category term="Java技术" scheme="http://example.com/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Optional 练习、实战</title>
    <link href="http://example.com/2019/01/15/java/Optional-practice/"/>
    <id>http://example.com/2019/01/15/java/Optional-practice/</id>
    <published>2019-01-15T10:01:54.000Z</published>
    <updated>2023-11-17T11:37:37.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Optional 类位于 java.util 包下，是 Java8 新增的类，使用它并结合 Lambda 表达式可以帮住我们进行优雅的判空，接下来通过实战来深入地学习它吧。</p><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><h2 id="使用静态方法构造-Optional"><a href="#使用静态方法构造-Optional" class="headerlink" title="使用静态方法构造 Optional"></a>使用静态方法构造 Optional</h2><h3 id="Optional-of-T-value"><a href="#Optional-of-T-value" class="headerlink" title="Optional.of(T value)"></a>Optional.of(T value)</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">of</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>通过源码可知通过该方法构造的 Optional 要求目标对象不能为 null，否则抛出 NPE，一般用于确定目标对象不为空，或者强制要求目标对象不能为 null，如果为 null，则任务抛出异常并终止程序的情况。第二种情况有点类似于断言。</p><h3 id="Optional-ofNullable-T-value"><a href="#Optional-ofNullable-T-value" class="headerlink" title="Optional.ofNullable(T value)"></a>Optional.ofNullable(T value)</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="literal">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>该构造方法可以接受一个为 null 的目标对象，如果目标对象为 null ，则默认一个 empty 的 Optional 对象</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> <span class="title class_">Optional</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="常用的-API"><a href="#常用的-API" class="headerlink" title="常用的 API"></a>常用的 API</h2><h3 id="ifPresent-方法"><a href="#ifPresent-方法" class="headerlink" title="ifPresent 方法"></a>ifPresent 方法</h3><p>场景：当我们远程调用一个服务的时候，因为不确定对方返回的结果是否为 null（毕竟是不信任编程），通常会这样写：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personFeginClient.queryById(id);</span><br><span class="line"><span class="keyword">if</span> (person != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">// doSomething...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>但是有了 Optional 后你可以：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personFeginClient.queryById(id);</span><br><span class="line">Optional.ofNullable(person) <span class="comment">// </span></span><br><span class="line">      .ifPresent(p -&gt; &#123;</span><br><span class="line">         <span class="comment">// doSomething...</span></span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></div><p>因为不确定 person 是否为 null， 所以用 <code>Optional.ofNullable</code>方法接受 person，<code>ifPresent</code>方法表示，只有当目标对象不为 null 的时候才执行该方法体的内容，如果执行的方法代码很多，你可以抽取出来，比如这样：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personService.queryById(id);</span><br><span class="line">Optional.ofNullable(person)</span><br><span class="line">      .ifPresent(<span class="built_in">this</span>::doSomething);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(Person person)</span> &#123;</span><br><span class="line"><span class="comment">// doSomething...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="orElse-方法"><a href="#orElse-方法" class="headerlink" title="orElse 方法"></a>orElse 方法</h3><p>orElse 方法可以指定当目标对象不为 null 时，返回该目标对象，为 null 时，返回一个默认对象：</p><p>以前这样写：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personService.queryById(id);</span><br><span class="line"><span class="keyword">if</span> (person == <span class="literal">null</span>) &#123;</span><br><span class="line">   person = DEFAULT_PERSON</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>现在可以这样写：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person = Optional.ofNullable(person).orElse(DEFAULT_PERSON);</span><br></pre></td></tr></table></figure></div><h3 id="orElseGet-方法"><a href="#orElseGet-方法" class="headerlink" title="orElseGet 方法"></a>orElseGet 方法</h3><p><code>orElseGet</code> 与 <code>orElse</code> 方法的区别在于，<code>orElseGet</code> 方法传入的参数为一个 <code>Supplier</code>接口的实现 ，当目标对象不为 null 时，返回该目标对象，为 null 时返回从 <code>Supplier</code> 获得的值，我们可以在该 Supplier 中执行获取默认对象的逻辑：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(person).orElseGet(<span class="built_in">this</span>::getDefault);</span><br><span class="line"><span class="keyword">private</span> Person <span class="title function_">getDefault</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="orElseThrow-方法"><a href="#orElseThrow-方法" class="headerlink" title="orElseThrow 方法"></a>orElseThrow 方法</h3><p>orElseThrow 方法和 orElse 方法区别是当目标对象为 null 时，可以抛出一个异常：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(person).orElseThrow(RuntimeException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure></div><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; mapper)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>Optional 的 map 方法和 Stream 的 map 方法类似，都是改变原目标对象并返回新对象的操作，而且，map 可以进行多次操作：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personService.queryById(id);</span><br><span class="line">Optional&lt;String&gt; s = Optional.ofNullable(person)</span><br><span class="line">      .map(Person::getName)</span><br><span class="line">      .map(String::toLowerCase)</span><br><span class="line">      .map(name -&gt; name.replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure></div><h3 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter 方法"></a>filter 方法</h3><p>和 Stream 的 filter 方法一样，Optional 也可以用此方法来过滤元素：</p><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> predicate.test(value) ? <span class="built_in">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personService.queryById(id);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">score</span> <span class="operator">=</span> Optional.ofNullable(person)</span><br><span class="line">      .filter(p -&gt; p.getName().startsWith(<span class="string">&quot;Z&quot;</span>))</span><br><span class="line">      .map(Person::getScore)</span><br><span class="line">      .orElse(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用 Optional，可以帮助我们更优雅地处理 null，不必像以前那样繁琐地 <code>if(obje == null)&#123;...&#125;</code>，同时它丰富的 API 也使我们的程序代码更简洁，可读性更好（当然是在熟悉其 api 的情况下;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Optional 类位于 java.util 包下，是 Java8 新增的类，使用它并结合 Lambda 表达式可以帮住我们进行优雅的判空，</summary>
      
    
    
    
    <category term="Java技术" scheme="http://example.com/categories/Java%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>读书：《Java程序员职场全攻略:从小工到专家》</title>
    <link href="http://example.com/2018/12/30/reading/java-workspace-strategy/"/>
    <id>http://example.com/2018/12/30/reading/java-workspace-strategy/</id>
    <published>2018-12-30T10:01:54.000Z</published>
    <updated>2023-11-17T11:37:36.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近读了一本书，书名：《Java程序员职场全攻略:从小工到专家》，豆瓣链接<a class="link"   href="https://book.douban.com/subject/4323628/" >https://book.douban.com/subject/4323628/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>由大佬吴亚峰所著，我看完后觉得对我有不少帮助，本书主要以菜鸟“蔡佳娃”和技术大牛“牛开复”对话的方式，来阐述程序员在职场上必将面临的情形以及处理方式，书中既有入职前的行业探秘、误区排除，也有入职后的口诀传授和江湖新锐兵器介绍。不仅与读者朋友们探讨了Java江湖中做事的学问，还探讨了一些职场中做人的道理，推荐看看，挺不错的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近读了一本书，书名：《Java程序员职场全攻略:从小工到专家》，豆瓣链接&lt;a class=&quot;link&quot;   href=&quot;https://b</summary>
      
    
    
    
    <category term="读书" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>MQTT 协议学习</title>
    <link href="http://example.com/2018/11/30/mq/mqtt/mqtt/"/>
    <id>http://example.com/2018/11/30/mq/mqtt/mqtt/</id>
    <published>2018-11-30T10:01:54.000Z</published>
    <updated>2023-11-17T11:37:37.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近项目里采用了 MQTT 来做长连接，实现即时通信和 APP 推送的功能，特此总结记录下。</p><h2 id="什么是-MQTT？"><a href="#什么是-MQTT？" class="headerlink" title="什么是 MQTT？"></a>什么是 MQTT？</h2><p>MQTT是一个轻量的、发布订阅模式的消息传输协议，专门针对低带宽和不稳定网络环境的物联网应用设计，它可以实现机器之间通信，在物联网方面有着巨大的优势，同时在app推送、即时通信也都有应用（我们公司就是在这两个场景上使用了 MQTT）。</p><p>MQTT官网: <a class="link"   href="http://mqtt.org/" >http://mqtt.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>MQTT V3.1.1协议规范: <a class="link"   href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html" >http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>MQTT 协议中文版: <a class="link"   href="https://legacy.gitbook.com/book/mcxiaoke/mqtt-cn/discussions/11" >https://legacy.gitbook.com/book/mcxiaoke/mqtt-cn/discussions/11 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="MQTT-协议特点"><a href="#MQTT-协议特点" class="headerlink" title="MQTT 协议特点"></a>MQTT 协议特点</h2><ol><li>简单的开放消息协议，开销很小。</li><li>基于 TCP&#x2F;IP。</li><li>1字节固定报头，2字节心跳报文，报文结构紧凑。</li><li>基于发布订阅模式（可以理解为消息队列）。</li><li>三种消息 Qos 支持：0-最多一次，1-最少一次，2-只有一次。</li></ol><h2 id="MQTT和传统MQ对比"><a href="#MQTT和传统MQ对比" class="headerlink" title="MQTT和传统MQ对比"></a>MQTT和传统MQ对比</h2><p>传统的消息中间件，例如RabbitMQ、Kafka 等都是面向微服务大数据等领域，负责消息的存储和转发，消息的生产者和消费者都是服务端应用。这种设计很适合服务端技术栈固定、语言平台固定的场景。而移动互联网和 IoT 领域则有所不同，这类场景更侧重于多语言多平台的海量设备接入，消息的生产和消费过程的业务属性很突出，传统的消息中间件并不适合这些领域。</p><p>MQTT 在设计上是一个面向移动互联网和 IoT 领域的无状态网关，只关心海量移动端设备的接入、管理和消息传输，消息数据的存储则都会路由给后端存储产品。</p><h3 id="适用场景对比"><a href="#适用场景对比" class="headerlink" title="适用场景对比"></a>适用场景对比</h3><table><thead><tr><th></th><th>适用场景</th></tr></thead><tbody><tr><td>MQTT</td><td>面向移动端场景，移动端场景一般都具备海量设备，单设备数据较少的特点。因此，微消息队列 MQTT 适用于拥有大量在线客户端（很多企业设备端过万，甚至上百万），但每个客户端消息较少的场景。</td></tr><tr><td>消息队列</td><td>面向服务端的消息引擎，主要用于服务组件之间的解耦、异步通知、削峰填谷等，服务器规模较小（极少企业服务器规模过万），但需要大量的消息处理，吞吐量要求高。因此，消息队列 MQ 适用于服务端进行大批量的数据处理和分析的场景。</td></tr></tbody></table><h2 id="MQTT-的-Broker"><a href="#MQTT-的-Broker" class="headerlink" title="MQTT 的 Broker"></a>MQTT 的 Broker</h2><p>Broker 是代理服务器，这里和消息队列的概念基本一样，生产者将消息发送至 Broker 中的 topic，消费者通过订阅 topic即可收到消息，MQTT 协议基于 Pub&#x2F;Sub 模式。</p><p>市面上的 Broker 有很多，如 RabbitMQ 就支持 MQTT，还有支持百万连接的 <a class="link"   href="http://www.emqtt.com/" >EMQ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 等。</p><h2 id="MQTT-的-Topic"><a href="#MQTT-的-Topic" class="headerlink" title="MQTT 的 Topic"></a>MQTT 的 Topic</h2><p>MQTT 基于主题(topic)进行消息路由，主题类似路径，如：</p><blockquote><p>dev&#x2F;push&#x2F;1</p><p>dev&#x2F;push&#x2F;#</p><p>test&#x2F;2&#x2F;feed&#x2F;comment</p><p>test&#x2F;+&#x2F;feed&#x2F;comment</p></blockquote><p>Topic 通过”&#x2F;“分隔层级，支持”+”、”#”通配符：</p><blockquote><p>“+”：表示通配一个层级，例如a&#x2F;+，匹配a&#x2F;x, a&#x2F;y</p><p>“#”：表示通配多个层级，例如a&#x2F;#，匹配a&#x2F;x, a&#x2F;b&#x2F;c&#x2F;d 。</p><p>注意：topic 可以就是 “#”，表示匹配所有 topic，”#”只能在末尾</p></blockquote><p><strong>注意：在 MQTT 协议中，消息发布（Pub）只能向特定名称Topic中发送消息，不支持匹配符。但是在订阅（Sub）时，支持通过通配符的方式订阅多个主题。”</strong></p><h2 id="MQTT-V3-1-1协议报文"><a href="#MQTT-V3-1-1协议报文" class="headerlink" title="MQTT V3.1.1协议报文"></a>MQTT V3.1.1协议报文</h2><h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><p>固定报头(Fixed header) + 可变报头(Variable header) + 报文有效载荷(Payload)</p><h3 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h3><table><thead><tr><th>类型名称</th><th>类型值</th><th>报文说明</th></tr></thead><tbody><tr><td>CONNECT</td><td>1</td><td>发起连接</td></tr><tr><td>CONNACK</td><td>2</td><td>连接回执</td></tr><tr><td>PUBLISH</td><td>3</td><td>发布消息</td></tr><tr><td>PUBACK</td><td>4</td><td>发布回执</td></tr><tr><td>PUBREC</td><td>5</td><td>QoS2消息回执</td></tr><tr><td>PUBREL</td><td>6</td><td>QoS2消息释放</td></tr><tr><td>PUBCOMP</td><td>7</td><td>QoS2消息完成</td></tr><tr><td>SUBSCRIBE</td><td>8</td><td>订阅主题</td></tr><tr><td>SUBACK</td><td>9</td><td>订阅回执</td></tr><tr><td>UNSUBSCRIBE</td><td>10</td><td>取消订阅</td></tr><tr><td>UNSUBACK</td><td>11</td><td>取消订阅回执</td></tr><tr><td>PINGREQ</td><td>12</td><td>PING请求</td></tr><tr><td>PINGRESP</td><td>13</td><td>PING响应</td></tr><tr><td>DISCONNECT</td><td>14</td><td>断开连接</td></tr></tbody></table><h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><p>客户端在无报文发送时，按保活周期 (KeepAlive) 定时向服务端发送 PINGREQ 心跳报文，服务端响应 PINGRESP 报文。PINGREQ&#x2F;PINGRESP报文均 2 个字节，服务端在 1.5 个心跳周期内，既没有收到客户端发布订阅报文，也没有收到PINGREQ 心跳报文时，主动心跳超时断开客户端 TCP 连接。</p><h2 id="QoS"><a href="#QoS" class="headerlink" title="QoS"></a>QoS</h2><blockquote><p> QoS 等于0：消息最多发送一次。</p><p>QoS 等于1：消息最少发送一次。</p><p>QoS 等于2：消息正好发送一次。</p></blockquote><p>MQTT 发布消息 QoS 保证不是端到端的，是客户端与服务器之间的。订阅者收到 MQTT 消息的 QoS 级别，最终取决于发布消息的 QoS 和主题订阅的 QoS，结果如下：</p><table><thead><tr><th>发布消息的QoS</th><th>主题订阅的QoS</th><th>接收消息的QoS</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>2</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>2</td><td>1</td></tr><tr><td>2</td><td>0</td><td>0</td></tr><tr><td>2</td><td>1</td><td>1</td></tr><tr><td>2</td><td>2</td><td>2</td></tr></tbody></table><h2 id="Clean-Session"><a href="#Clean-Session" class="headerlink" title="Clean Session"></a>Clean Session</h2><p>MQTT客户端向服务器发起CONNECT请求时，可以通过’Clean Session’标志设置会话。</p><p>Clean Session&#x3D;0，表示创建一个持久会话，在客户端断开连接时，会话仍然保持并保存离线消息，直到会话超时注销。</p><p>Clean Session&#x3D;1，表示创建一个新的临时会话，在客户端断开时，会话自动销毁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近项目里采用了 MQTT 来做长连接，实现即时通信和 APP 推送的功能，特此总结记录下。&lt;/p&gt;
&lt;h2 id=&quot;什么是-MQTT？&quot;&gt;</summary>
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="MQTT" scheme="http://example.com/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 笔记整理</title>
    <link href="http://example.com/2018/11/15/mq/kafka/kafka-note/"/>
    <id>http://example.com/2018/11/15/mq/kafka/kafka-note/</id>
    <published>2018-11-15T10:01:54.000Z</published>
    <updated>2023-11-17T11:37:37.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前阵子做了个车联网的项目，用到了kafka，今晚回来的早，写一篇对 Kafka 的笔记整理和总结吧。</p><h2 id="Kafka-概述"><a href="#Kafka-概述" class="headerlink" title="Kafka 概述"></a>Kafka 概述</h2><p>Kafka 是一个由 Scala 语言实现的开源、轻量、分布式、具有分区和副本能力的，基于 ZK 实现分布式协调的高性能，高吞吐的分布式消息订阅消息中间件。与传统的消息队列相比，Kafka 可以更好地处理活跃的流数据。可处理每秒几十万、上百万的请求，非常适用于行为跟踪、日志搜集。</p><h3 id="Pull-or-Push？"><a href="#Pull-or-Push？" class="headerlink" title="Pull or Push？"></a>Pull or Push？</h3><p>Kafka 是消费者主动去获得消息（pull 模式）。</p><h2 id="kafka-架构"><a href="#kafka-架构" class="headerlink" title="kafka 架构"></a>kafka 架构</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://www.zhengyk.cn/images/kafka-framework.jpg"                      alt="image-20181121153854001"                ></p><h2 id="Kafka-基本概念"><a href="#Kafka-基本概念" class="headerlink" title="Kafka 基本概念"></a>Kafka 基本概念</h2><h3 id="主题："><a href="#主题：" class="headerlink" title="主题："></a>主题：</h3><p>​Kafka 将一组消息抽象成一个主题，也就是说，一个主题就是对消息的一个分类，生产者将消息发到topic，消费者通过订阅 topic 或者 topic 的某些分区进行消费。</p><h3 id="消息："><a href="#消息：" class="headerlink" title="消息："></a>消息：</h3><p>​消息 Message 是 Kafka 的基本通信单元，由固定长度的消息头和可变长度的消息体组成。</p><h3 id="分区："><a href="#分区：" class="headerlink" title="分区："></a>分区：</h3><p>​每个 Topic 可以进行分区（Partition），每个分区是一个有序队列，用于存储消息。分区在物理上对应一个文件夹，编号从0开始，依次递增，默认有 50 个分区，可配置。</p><h4 id="分区的作用？"><a href="#分区的作用？" class="headerlink" title="分区的作用？"></a>分区的作用？</h4><p>若没有分区，一个topic对应的消息集在分布式集群服务组中，就会分布不均匀，即可能导致某台服务器A记录当前topic的消息集很多，若此topic的消息压力很大的情况下，服务器A就可能导致压力很大，吞吐也容易导致瓶颈。</p><p>分区使得 Kafka 在并发处理上变得更加容易，理论上来说，分区越多吞吐量越高，但这要根据实际集群环境和业务场景而定。同时，分区也是 Kafka 保证消息被顺序消费以及对消息进行负载均衡的基础。</p><p>为了保证分区的均匀分布，建议创建的分区数是节点数的整数倍。</p><p>Kafka 只能保证一个分区内的消息有序性，不能保证跨分区消息的有序性，每条消息被追加到相应的分区中，是顺序写入磁盘（<a class="link"   href="https://www.zhihu.com/question/26028619/answer/32932317" >为什么顺序写入磁盘速度比随机写入磁盘快？ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>），因此效率非常高，是 Kafka 高吞吐的重要保证。</p><p>Kafka 不会立即删除已被消费的消息，也不会一直被存储，Kafka 提供了两种删除老数据的策略，一是基于消息已存储时间，二是基于分区大小，可通过配置文件配置。</p><h3 id="副本："><a href="#副本：" class="headerlink" title="副本："></a>副本：</h3><p>每个分区可以有一到多个副本（Replica）,分区的副本在集群的不同节点上，用以高可用。</p><p>副本在逻辑上抽象为 Log 对象，即分区的副本与日志对象是对应的。 </p><h3 id="Leader-副本和-Follower-副本："><a href="#Leader-副本和-Follower-副本：" class="headerlink" title="Leader 副本和 Follower 副本："></a>Leader 副本和 Follower 副本：</h3><p>每个分区可以有多个副本，这就需要保证分区多个副本之间的数据一致性，Kafka 会选举该分区的某个副本为 Leader 副本，而该分区其他副本为 Follower 副本，只有 Leader 副本才负责处理客户端的读写请求，Follower 副本从 Leader 副本同步数据（如果没有 Leader，那么所有的副本都进行读写，数据同步就太复杂、麻烦）。</p><p>Leader 和 Follower 不固定，如果 Leader 失效，会重新选举另一个 Leader。</p><p><em><strong>注意：分区数可以大于节点数，副本数不能大于节点数，因为副本需要分布在不同节点上，这样才能达到备份的目的</strong></em></p><h3 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h3><p>任何发布到分区的消息会被直接追加到日志文件（.log）的尾部，每条消息在文件内部对一个偏移量，消费者通过控制偏移量来对消息进行消费。</p><h3 id="日志段"><a href="#日志段" class="headerlink" title="日志段"></a>日志段</h3><p>一个日志又被划分为一个个日志段，LogSegment，是一个逻辑概念，对应一个.log文件和两个 .index文件。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>Kafka 集群中每个节点可称为一个代理（Broker），每个代理具有唯一标识 id，在集群中，每增加一台代理就要为其配置i唯一标识id，</p><p>Kafka支持异步发送消息kafka1.0以后默认支持异步发送,发送后会有一个回调</p><p>Kafka消息自动持久化，一般保存7天。</p><h4 id="消息组的概念："><a href="#消息组的概念：" class="headerlink" title="消息组的概念："></a>消息组的概念：</h4><p>每个消费者属于特定的消费者组，每个消费者组有一个 groupId，消费者的默认消费者组是test-consumer-group，可以为消费者指定消费者组。</p><p>每个消费者有特定的唯一id，如果不指定，Kafka 会给消费者默认生成一个全局唯一 Id，消息存储到分区的算法默认是先计算出 groupId 的 hash 值，然后对分区数（默认50）进行取模得到的值就是消息要存储的目标分区。</p><p>同一个消费组内的消费者存在消息竞争关系，同一个组内的消费者消费完某条消息且 commit后不可以重复消费了，但是其他消费组内的消费者如果还未消费该消息，仍然可以继续消费。</p><p>消费者组是 Kafka 用来实现广播和单播的手段，实现消息广播要让消费者数据不同的消费者组，实现单播要让消费者属于相同的消费者组。</p><p>对比 RabbitMQ，Kafka 没有 Queue 的概念，但是通过 groupId，同样实现了 RabbitMQ 中 Queue 的作用。</p><h5 id="AUTO-OFFSET-RESET-CONFIG-参数"><a href="#AUTO-OFFSET-RESET-CONFIG-参数" class="headerlink" title="AUTO_OFFSET_RESET_CONFIG 参数"></a>AUTO_OFFSET_RESET_CONFIG 参数</h5><p>对于新的 groupid：</p><blockquote><p>如果设置为 earlist，那么他会从最早的消息开始消费（默认）。</p><p>如果设置为 latest，那么已经消费最大的 offset。</p><p>如果设置为 none，如果没有消息，会抛出异常。</p></blockquote><h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p>Kafka 在 Zookeeper 中维护了 一个 ISR(In-sync Replica)，保存同步的副本列表，该列表保存的是与 Leader 副本保持消息同步的所有副本所在代理的唯一标识id，如果某个 Follower 宕机，则该 Follower 代理 id 将从 ISR 中移除。</p><h4 id="如何判断节点是否在同步状态中（Kafka-存活）？"><a href="#如何判断节点是否在同步状态中（Kafka-存活）？" class="headerlink" title="如何判断节点是否在同步状态中（Kafka 存活）？"></a>如何判断节点是否在同步状态中（Kafka 存活）？</h4><p>必须满足两个条件：</p><ol><li>一个存活的节点必须与 ZK 保持连接，这个主要通过 ZK 的心跳机制实现。</li><li>如果一个节点是 Follower 副本，那么该副本必须能及时与 Leader 副本保持消息同步，不能落后太多。</li></ol><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>ZK 负责存储 Kafka 的元数据信息，并协调 Kafka 集群。通过 ZK，可以很方便地对 Kafka 集群进行管理、水平扩展或数据迁移。</p><h2 id="Kafka-特性"><a href="#Kafka-特性" class="headerlink" title="Kafka 特性"></a>Kafka 特性</h2><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>文件系统、磁盘存储、B树</p><p>RabbitMQ 有开启、关闭持久化的操作，Kafka 本身就是把消息顺序写入到磁盘。</p><h3 id="高吞吐量"><a href="#高吞吐量" class="headerlink" title="高吞吐量"></a>高吞吐量</h3><p>顺序存储，零拷贝（避免缓冲区），主题可分区</p><h3 id="高扩展性"><a href="#高扩展性" class="headerlink" title="高扩展性"></a>高扩展性</h3><p>Zookeeper对 Kafka 进行协调管理</p><h3 id="多客户端支持"><a href="#多客户端支持" class="headerlink" title="多客户端支持"></a>多客户端支持</h3><p>Kafka 采用 Scala 开发，但 Kafka 支持多种语言的客户端</p><h3 id="轻量级"><a href="#轻量级" class="headerlink" title="轻量级"></a>轻量级</h3><h3 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h3><p>Kafka 支持Gzip、Snappy、LZ4 三种压缩协议。通常把多条消息组成 MessageSet，然后把 MessageSet放到一条消息里面去，从而提高压缩比率进而提高吞吐量（批量发送），但是代价是降低了实时性。</p><h2 id="Kafka-应用场景"><a href="#Kafka-应用场景" class="headerlink" title="Kafka 应用场景"></a>Kafka 应用场景</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h3 id="应用监控"><a href="#应用监控" class="headerlink" title="应用监控"></a>应用监控</h3><h3 id="网站用户行为跟踪"><a href="#网站用户行为跟踪" class="headerlink" title="网站用户行为跟踪"></a>网站用户行为跟踪</h3><h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h3><h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><h2 id="Kafka-如何保证消息的可靠性传输？"><a href="#Kafka-如何保证消息的可靠性传输？" class="headerlink" title="Kafka 如何保证消息的可靠性传输？"></a>Kafka 如何保证消息的可靠性传输？</h2><h3 id="消费端丢失数据"><a href="#消费端丢失数据" class="headerlink" title="消费端丢失数据"></a>消费端丢失数据</h3><p>当消费者消费到消息时，默认情况下，会自动提交此消息的 offset 给 Kafka，为了保证消息的可靠性，可以设置手动提交 offset，即关闭自动提交，当消费者正常消费完后，再手动提交 offset（和 RabbitMQ 手动回执一个 ack 原理类似）。</p><p>这样可能会有消息重复消费的问题，如消费完消息后，在手动后提交 offset 之前，消费者自己挂了，那么下次还会消费此消息，所以还需要在应用层保证幂等性。</p><p>相关参数：ENABLE_AUTO_COMMIT</p><h3 id="Kafka-数据丢失"><a href="#Kafka-数据丢失" class="headerlink" title="Kafka 数据丢失"></a>Kafka 数据丢失</h3><p>Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。此时其他的 follower 的数据还没同步完成，造成数据丢失。</p><p>可以设置如下 2 个参数：</p><ul><li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 至少 2 个副本。</li><li>设置 <code>min.insync.replicas</code> ：最小 ISR，这个值必须大于 1，要求一个 leader 至少感知到有至少一个正常的 follower ，确保 leader 挂了后有一个 follower 能顶替。</li></ul><h3 id="生产者数据丢失"><a href="#生产者数据丢失" class="headerlink" title="生产者数据丢失"></a>生产者数据丢失</h3><p>Kafka 1.0 版本以后，生产者发送消息默认是异步发送。发送成功后，会给生产者一个回调 CallBack，我们可以写一个回调函数来判断消息是否发送成功。</p><p>再配置两个参数：</p><ul><li>在 producer 端设置 <code>acks=all</code>：这个是要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li><li>在 producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思）：这个是**要求一旦写入失败，就无限重试</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前阵子做了个车联网的项目，用到了kafka，今晚回来的早，写一篇对 Kafka 的笔记整理和总结吧。&lt;/p&gt;
&lt;h2 id=&quot;Kafka-概</summary>
      
    
    
    
    <category term="消息队列" scheme="http://example.com/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="Kafka" scheme="http://example.com/tags/Kafka/"/>
    
  </entry>
  
</feed>
